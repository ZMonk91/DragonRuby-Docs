{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This documentation is still under development. Click here to contribute DragonRuby Game Toolkit # DragonRuby-GTK is a professional grade (yet beginner friendly) 2D game engine. It's tiny (~3MB), fast as hell, and cross-platform (including consoles). Features # Dirt simple apis capable of creating complex 2D games. Fast as hell. Powered by highly optimized C code written by Ryan C. Gordon, the creator of SDL (a library that powers every commercial game engine in the world). Battle tested by Amir Rajan, a critically acclaimed indie game dev. Tiny. Like really tiny. The entire engine is a few megabytes. Hot loaded, realtime coding, optimized to provide constant feedback to the dev. Productive and an absolute joy to use. Turn key builds for Windows, MacOS, and Linux with seamless publishing to Itch.io. Cross platform: PC, Mac, Linux, iOS, Android, Nintendo Switch, XBOX One, and PS4 (mobile and console compilation requires a business entity, NDA verification, and a Professional GTK License, contact us). Get The Toolkit # You can purchase DragonRuby-GTK on Itch.io . A 'Free Unrestricted License' is also available. For more information, please see Licensing Info API # The GTK's entire API is displayed here and can be found in the Tech Demo sample app that ships with DragonRuby-GTK Community # There are many facets to reach out and communicate with fellow Dragon Riders . Discord being the most popular. ** Discord ** - Amir (one of the creators of DragonRuby) is always available to help you out. So take the time to join the community Discord. ** Newsletter ** - Keep updated with related development news ** Forums ** - This provides community members a registry of everyone using DragonRuby. Itch.io holds a lot of game jams, and it'd be awesome if Dragon Riders had a central place to find each other.","title":"Main"},{"location":"#dragonruby-game-toolkit","text":"DragonRuby-GTK is a professional grade (yet beginner friendly) 2D game engine. It's tiny (~3MB), fast as hell, and cross-platform (including consoles).","title":"DragonRuby Game Toolkit"},{"location":"#features","text":"Dirt simple apis capable of creating complex 2D games. Fast as hell. Powered by highly optimized C code written by Ryan C. Gordon, the creator of SDL (a library that powers every commercial game engine in the world). Battle tested by Amir Rajan, a critically acclaimed indie game dev. Tiny. Like really tiny. The entire engine is a few megabytes. Hot loaded, realtime coding, optimized to provide constant feedback to the dev. Productive and an absolute joy to use. Turn key builds for Windows, MacOS, and Linux with seamless publishing to Itch.io. Cross platform: PC, Mac, Linux, iOS, Android, Nintendo Switch, XBOX One, and PS4 (mobile and console compilation requires a business entity, NDA verification, and a Professional GTK License, contact us).","title":"Features"},{"location":"#get-the-toolkit","text":"You can purchase DragonRuby-GTK on Itch.io . A 'Free Unrestricted License' is also available. For more information, please see Licensing Info","title":"Get The Toolkit"},{"location":"#api","text":"The GTK's entire API is displayed here and can be found in the Tech Demo sample app that ships with DragonRuby-GTK","title":"API"},{"location":"#community","text":"There are many facets to reach out and communicate with fellow Dragon Riders . Discord being the most popular. ** Discord ** - Amir (one of the creators of DragonRuby) is always available to help you out. So take the time to join the community Discord. ** Newsletter ** - Keep updated with related development news ** Forums ** - This provides community members a registry of everyone using DragonRuby. Itch.io holds a lot of game jams, and it'd be awesome if Dragon Riders had a central place to find each other.","title":"Community"},{"location":"00-tutorial/","text":"This documentation is still under development. Click here to contribute Getting Started # The following are sections designed to cater to your experience level. If you are not sure where to start, try out the Beginner section and adjust depending on how easy it is for you. Beginner - No Programming Experience Intermediate - Familiar with Unity/GML Advanced - Familiar with Dynamically Typed Languages #","title":"00 tutorial"},{"location":"00-tutorial/#getting-started","text":"The following are sections designed to cater to your experience level. If you are not sure where to start, try out the Beginner section and adjust depending on how easy it is for you. Beginner - No Programming Experience Intermediate - Familiar with Unity/GML Advanced - Familiar with Dynamically Typed Languages","title":"Getting Started"},{"location":"00-tutorial/#_1","text":"","title":""},{"location":"01-high-level/","text":"This documentation is still under development. Click here to contribute General Stuff # You have 1280x720 pixels to work with. The bottom left corner is 0, 0 with X increasing going right, and Y increasing going up. The game is on a fixed 60 fps cycle (no delta time needed). Come to the Discord if you need help: http://discord.dragonruby.org Going through all the sample apps is a REALLY GOOD IDEA. Most sample apps contain a recorded replay/demo. So just double click watch-recording to see a full presentation of the sample. Entry Point # For all the examples in the other documentation files. It's assumed they are being placed into the follow code block: # Entry point placed in main.rb def tick args args.outputs.labels << [100, 100, 'hello world'] end New to Ruby # If you are a complete beginner and have never coded before: Run the 00_beginner_ruby_primer sample app and work through it. Video walkthrough: https://s3.amazonaws.com/s3.dragonruby.org/dragonruby-gtk-primer.mp4 Read all the code in the 00_intermediate_ruby_primer sample app. Video walkthrough: https://s3.amazonaws.com/s3.dragonruby.org/dragonruby-gtk-intermediate.mp4 There is also a free course you can sign up for at http://dragonruby.school","title":"General Information"},{"location":"01-high-level/#general-stuff","text":"You have 1280x720 pixels to work with. The bottom left corner is 0, 0 with X increasing going right, and Y increasing going up. The game is on a fixed 60 fps cycle (no delta time needed). Come to the Discord if you need help: http://discord.dragonruby.org Going through all the sample apps is a REALLY GOOD IDEA. Most sample apps contain a recorded replay/demo. So just double click watch-recording to see a full presentation of the sample.","title":"General Stuff"},{"location":"01-high-level/#entry-point","text":"For all the examples in the other documentation files. It's assumed they are being placed into the follow code block: # Entry point placed in main.rb def tick args args.outputs.labels << [100, 100, 'hello world'] end","title":"Entry Point"},{"location":"01-high-level/#new-to-ruby","text":"If you are a complete beginner and have never coded before: Run the 00_beginner_ruby_primer sample app and work through it. Video walkthrough: https://s3.amazonaws.com/s3.dragonruby.org/dragonruby-gtk-primer.mp4 Read all the code in the 00_intermediate_ruby_primer sample app. Video walkthrough: https://s3.amazonaws.com/s3.dragonruby.org/dragonruby-gtk-intermediate.mp4 There is also a free course you can sign up for at http://dragonruby.school","title":"New to Ruby"},{"location":"02-labels/","text":"This documentation is still under development. Click here to contribute Labels # Labels display text. Minimum Code # Creates a label with black text at location 100, 100. # X Y TEXT args . outputs . labels << [ 100 , 100 , \"Hello world\" ] Font Size # The size can be a number between -10 and +10 . The default size is 0 . # X Y TEXT SIZE args . outputs . labels << [ 100 , 100 , \"Hello world\" , 5 ] Alignment # Alignment values are 0 (left, default), 1 (center), and 2 (right). The value must come after the size. A label smack dab in the center of the screen, with a center alignment: # X Y TEXT SIZE ALIGNMENT args . outputs . labels << [ 640 , 360 , \"Hello world\" , 0 , 1 ] RGBA - Colors and Alpha # Labels can have colors. The value for the color is an number between 0 and 255 . A green label with 50% opacity. # X Y TEXT RED GREEN BLUE ALPHA args . outputs . labels << [ 640 , 360 , \"Hello world\" , 0 , 255 , 0 , 128 ] A green label with size and alignment. # X Y TEXT SIZE ALIGNMENT RED GREEN BLUE ALPHA args . outputs . labels << [ 640 , 360 , \"Hello world\" , 0 , 1 , 0 , 255 , 0 , 128 ] Custom Font # You can override the font for a label. The font needs to be under the mygame directory. It's recommended that you create a fonts folder to keep things organized. Here is how you create a label with a font named coolfont.ttf under a directory mygame/fonts . # X Y TEXT SIZE ALIGNMENT RED GREEN BLUE ALPHA FONT FILE args . outputs . labels << [ 640 , 360 , \"Hello world\" , 0 , 1 , 0 , 0 , 0 , 255 , \"fonts/coolfont.ttf\" ] Hashes (Advanced) # If you want a more readable invocation. You can use the following hash to create a label. Any parameters that are not specified will be given a default value. The keys of the hash can be provided in any order. Here is how you create a green label with a font named coolfont.ttf under a directory mygame/fonts using the helper method (providing all the parameters). args . outputs . labels << { x : 200 , y : 550 , text : \"dragonruby\" , size_enum : 2 , alignment_enum : 1 , r : 155 , g : 50 , b : 50 , a : 255 , font : \"fonts/manaspc.ttf\" } Duck Typing (Advanced) # You can also create a class with line properties and render it as a primitive. ALL properties must on the class. ADDITIONALLY, a method called primitive_marker must be defined on the class. Here is an example: # Create type with ALL sprite properties AND primitive_marker class Label attr_accessor :x , :y , :text , :size_enum , :alignment_enum , :font , :r , :g , :b , :a def primitive_marker :label end end # Inherit from type class TitleLabel < Label # constructor def initialize x , y , text self . x = x self . y = y self . text = text end end # render layer label args . outputs . label << TitleLabel . new ( 10 , 10 , \"The Game\" ) Related Samples # 01_api_01_labels 01_api_99_tech_demo (includes recording) 10_save_load_game (includes recording) 18_moddable_game 19_lowrez_jam_01_hello_world 99_sample_game_return_of_serenity","title":"Labels"},{"location":"02-labels/#labels","text":"Labels display text.","title":"Labels"},{"location":"02-labels/#minimum-code","text":"Creates a label with black text at location 100, 100. # X Y TEXT args . outputs . labels << [ 100 , 100 , \"Hello world\" ]","title":"Minimum Code"},{"location":"02-labels/#font-size","text":"The size can be a number between -10 and +10 . The default size is 0 . # X Y TEXT SIZE args . outputs . labels << [ 100 , 100 , \"Hello world\" , 5 ]","title":"Font Size"},{"location":"02-labels/#alignment","text":"Alignment values are 0 (left, default), 1 (center), and 2 (right). The value must come after the size. A label smack dab in the center of the screen, with a center alignment: # X Y TEXT SIZE ALIGNMENT args . outputs . labels << [ 640 , 360 , \"Hello world\" , 0 , 1 ]","title":"Alignment"},{"location":"02-labels/#rgba-colors-and-alpha","text":"Labels can have colors. The value for the color is an number between 0 and 255 . A green label with 50% opacity. # X Y TEXT RED GREEN BLUE ALPHA args . outputs . labels << [ 640 , 360 , \"Hello world\" , 0 , 255 , 0 , 128 ] A green label with size and alignment. # X Y TEXT SIZE ALIGNMENT RED GREEN BLUE ALPHA args . outputs . labels << [ 640 , 360 , \"Hello world\" , 0 , 1 , 0 , 255 , 0 , 128 ]","title":"RGBA - Colors and Alpha"},{"location":"02-labels/#custom-font","text":"You can override the font for a label. The font needs to be under the mygame directory. It's recommended that you create a fonts folder to keep things organized. Here is how you create a label with a font named coolfont.ttf under a directory mygame/fonts . # X Y TEXT SIZE ALIGNMENT RED GREEN BLUE ALPHA FONT FILE args . outputs . labels << [ 640 , 360 , \"Hello world\" , 0 , 1 , 0 , 0 , 0 , 255 , \"fonts/coolfont.ttf\" ]","title":"Custom Font"},{"location":"02-labels/#hashes-advanced","text":"If you want a more readable invocation. You can use the following hash to create a label. Any parameters that are not specified will be given a default value. The keys of the hash can be provided in any order. Here is how you create a green label with a font named coolfont.ttf under a directory mygame/fonts using the helper method (providing all the parameters). args . outputs . labels << { x : 200 , y : 550 , text : \"dragonruby\" , size_enum : 2 , alignment_enum : 1 , r : 155 , g : 50 , b : 50 , a : 255 , font : \"fonts/manaspc.ttf\" }","title":"Hashes (Advanced)"},{"location":"02-labels/#duck-typing-advanced","text":"You can also create a class with line properties and render it as a primitive. ALL properties must on the class. ADDITIONALLY, a method called primitive_marker must be defined on the class. Here is an example: # Create type with ALL sprite properties AND primitive_marker class Label attr_accessor :x , :y , :text , :size_enum , :alignment_enum , :font , :r , :g , :b , :a def primitive_marker :label end end # Inherit from type class TitleLabel < Label # constructor def initialize x , y , text self . x = x self . y = y self . text = text end end # render layer label args . outputs . label << TitleLabel . new ( 10 , 10 , \"The Game\" )","title":"Duck Typing (Advanced)"},{"location":"02-labels/#related-samples","text":"01_api_01_labels 01_api_99_tech_demo (includes recording) 10_save_load_game (includes recording) 18_moddable_game 19_lowrez_jam_01_hello_world 99_sample_game_return_of_serenity","title":"Related Samples"},{"location":"03-solids-and-borders/","text":"This documentation is still under development. Click here to contribute Solids and Borders # Solids and Borders are great to use as place holders for sprites. Minimum Code # Creates a solid black rectangle located at 100, 100. 160 pixels wide and 90 pixels tall. # X Y WIDTH HEIGHT args . outputs . solids << [ 100 , 100 , 160 , 90 ] Creates an unfilled black-bordered rectangle located at 100, 100. 160 pixels wide and 90 pixels tall. # X Y WIDTH HEIGHT args . outputs . borders << [ 100 , 100 , 160 , 90 ] RGBA - Colors and Alpha # The value for the color and alpha is an number between 0 and 255 . The alpha property is optional and will be set to 255 if not specified. Creates a green solid rectangle with an opacity of 50%. # X Y WIDTH HEIGHT RED GREEN BLUE ALPHA args . outputs . solids << [ 100 , 100 , 160 , 90 , 0 , 255 , 0 , 128 ] Creates an unfilled green-bordered rectangle located at 100, 100. 160 pixels wide and 90 pixels tall and an opacity of 50%. # X Y WIDTH HEIGHT RED GREEN BLUE ALPHA args . outputs . borders << [ 100 , 100 , 160 , 90 , 0 , 255 , 0 , 128 ] Creates a solid gray rectangle that covers the entire scene. Like a background. The opacity is excluded because it's 100% opaque (which has a value of 255). # X Y WIDTH HEIGHT RED GREEN BLUE args . outputs . solids << [ 0 , 0 , 1280 , 720 , 128 , 128 , 128 ] Hash (Advanced) # If you want a more readable invocation. You can use the following hash to create a solid. Any parameters that are not specified will be given a default value. The keys of the hash can be provided in any order. args . outputs . solids << { x : 0 , y : 0 , w : 100 , h : 100 , r : 0 , g : 255 , b : 0 , a : 255 } args . outputs . borders << { x : 0 , y : 0 , w : 100 , h : 100 , r : 0 , g : 255 , b : 0 , a : 255 } Duck Typing (Advanced) # You can also create a class with solid/border properties and render it as a primitive. ALL properties must on the class. ADDITIONALLY, a method called primitive_marker must be defined on the class. Here is an example: # Create type with ALL solid/border properties AND primitive_marker class Solid ( or Border ) attr_accessor :x , :y , :w , :h , :r , :g , :b , :a_x def primitive_marker :solid ( or :border ) end end # Inherit from type class Square < Solid ( or Border ) # constructor def initialize x , y , size self . x = x self . y = y self . w = size self . h = size end end # render solid/border args . outputs . solids << Square . new ( 10 , 10 , 32 ) args . outputs . borders << Square . new ( 10 , 10 , 32 ) Related Samples # 01_api_03_rects 01_api_99_tech_demo (includes recording) 02_collisions 12_top_down_area (includes recording) 99_sample_game_flappy_dragon (includes recording) 08_platformer_collisions 20_roguelike_starting_point 99_sample_game_pong (includes recording)","title":"Solids & Borders"},{"location":"03-solids-and-borders/#solids-and-borders","text":"Solids and Borders are great to use as place holders for sprites.","title":"Solids and Borders"},{"location":"03-solids-and-borders/#minimum-code","text":"Creates a solid black rectangle located at 100, 100. 160 pixels wide and 90 pixels tall. # X Y WIDTH HEIGHT args . outputs . solids << [ 100 , 100 , 160 , 90 ] Creates an unfilled black-bordered rectangle located at 100, 100. 160 pixels wide and 90 pixels tall. # X Y WIDTH HEIGHT args . outputs . borders << [ 100 , 100 , 160 , 90 ]","title":"Minimum Code"},{"location":"03-solids-and-borders/#rgba-colors-and-alpha","text":"The value for the color and alpha is an number between 0 and 255 . The alpha property is optional and will be set to 255 if not specified. Creates a green solid rectangle with an opacity of 50%. # X Y WIDTH HEIGHT RED GREEN BLUE ALPHA args . outputs . solids << [ 100 , 100 , 160 , 90 , 0 , 255 , 0 , 128 ] Creates an unfilled green-bordered rectangle located at 100, 100. 160 pixels wide and 90 pixels tall and an opacity of 50%. # X Y WIDTH HEIGHT RED GREEN BLUE ALPHA args . outputs . borders << [ 100 , 100 , 160 , 90 , 0 , 255 , 0 , 128 ] Creates a solid gray rectangle that covers the entire scene. Like a background. The opacity is excluded because it's 100% opaque (which has a value of 255). # X Y WIDTH HEIGHT RED GREEN BLUE args . outputs . solids << [ 0 , 0 , 1280 , 720 , 128 , 128 , 128 ]","title":"RGBA - Colors and Alpha"},{"location":"03-solids-and-borders/#hash-advanced","text":"If you want a more readable invocation. You can use the following hash to create a solid. Any parameters that are not specified will be given a default value. The keys of the hash can be provided in any order. args . outputs . solids << { x : 0 , y : 0 , w : 100 , h : 100 , r : 0 , g : 255 , b : 0 , a : 255 } args . outputs . borders << { x : 0 , y : 0 , w : 100 , h : 100 , r : 0 , g : 255 , b : 0 , a : 255 }","title":"Hash (Advanced)"},{"location":"03-solids-and-borders/#duck-typing-advanced","text":"You can also create a class with solid/border properties and render it as a primitive. ALL properties must on the class. ADDITIONALLY, a method called primitive_marker must be defined on the class. Here is an example: # Create type with ALL solid/border properties AND primitive_marker class Solid ( or Border ) attr_accessor :x , :y , :w , :h , :r , :g , :b , :a_x def primitive_marker :solid ( or :border ) end end # Inherit from type class Square < Solid ( or Border ) # constructor def initialize x , y , size self . x = x self . y = y self . w = size self . h = size end end # render solid/border args . outputs . solids << Square . new ( 10 , 10 , 32 ) args . outputs . borders << Square . new ( 10 , 10 , 32 )","title":"Duck Typing (Advanced)"},{"location":"03-solids-and-borders/#related-samples","text":"01_api_03_rects 01_api_99_tech_demo (includes recording) 02_collisions 12_top_down_area (includes recording) 99_sample_game_flappy_dragon (includes recording) 08_platformer_collisions 20_roguelike_starting_point 99_sample_game_pong (includes recording)","title":"Related Samples"},{"location":"04-lines/","text":"This documentation is still under development. Click here to contribute Lines # Lines are 1 pixel wide and can be diagonal. Minimum Code # Creates a black line from the bottom left corner to the top right corner. # X1 Y1 X2 Y2 args . outputs . lines << [ 0 , 0 , 1280 , 720 ] Creates a black vertical line through the center of the scene. # X1 Y1 X2 Y2 args . outputs . lines << [ 640 , 0 , 640 , 720 ] Creates a black horizontal line through the center of the scene. # X1 Y1 X2 Y2 args . outputs . lines << [ 0 , 360 , 1280 , 360 ] RGBA - Colors and Alpha # The value for the color and alpha is an number between 0 and 255 . The alpha property is optional and will be set to 255 if not specified. Creates a green horizontal line through the center of the scene with an opacity of 50%. # X1 Y1 X2 Y2 RED GREEN BLUE ALPHA args . outputs . lines << [ 0 , 360 , 1280 , 360 , 0 , 255 , 0 , 128 ] Creates a green vertical line through the center of the scene. The opacity is excluded because it's 100% opaque (which has a value of 255). # X1 Y1 X2 Y2 RED GREEN BLUE args . outputs . lines << [ 640 , 0 , 640 , 720 , 0 , 255 , 0 ] Hash (Advanced) # If you want a more readable invocation. You can use the following hash to create a line. Any parameters that are not specified will be given a default value. The keys of the hash can be provided in any order. args . outputs . lines << { x : 0 , y : 0 , x2 : 1280 , y2 : 720 , r : 0 , g : 255 , b : 0 , a : 255 } Duck Typing (Advanced) # You can also create a class with line properties and render it as a primitive. ALL properties must on the class. ADDITIONALLY, a method called primitive_marker must be defined on the class. Here is an example: # Create type with ALL line properties AND primitive_marker class Line attr_accessor :x , :y , :x2 , :y2 , :r , :g , :b , :a def primitive_marker :line end end # Inherit from type class VerticalLine < Line # constructor def initialize x , y , h self . x = x self . y = y self . x2 = x self . y2 = y + h end end # render line args . outputs . lines << VerticalLine . new ( 10 , 10 , 100 ) Related Samples # 01_api_02_lines 01_api_99_tech_demo (includes recording) 06_coordinate_systems (includes recording) 19_lowrez_jam_01_hello_world 99_sample_game_pong (includes recording)","title":"Lines"},{"location":"04-lines/#lines","text":"Lines are 1 pixel wide and can be diagonal.","title":"Lines"},{"location":"04-lines/#minimum-code","text":"Creates a black line from the bottom left corner to the top right corner. # X1 Y1 X2 Y2 args . outputs . lines << [ 0 , 0 , 1280 , 720 ] Creates a black vertical line through the center of the scene. # X1 Y1 X2 Y2 args . outputs . lines << [ 640 , 0 , 640 , 720 ] Creates a black horizontal line through the center of the scene. # X1 Y1 X2 Y2 args . outputs . lines << [ 0 , 360 , 1280 , 360 ]","title":"Minimum Code"},{"location":"04-lines/#rgba-colors-and-alpha","text":"The value for the color and alpha is an number between 0 and 255 . The alpha property is optional and will be set to 255 if not specified. Creates a green horizontal line through the center of the scene with an opacity of 50%. # X1 Y1 X2 Y2 RED GREEN BLUE ALPHA args . outputs . lines << [ 0 , 360 , 1280 , 360 , 0 , 255 , 0 , 128 ] Creates a green vertical line through the center of the scene. The opacity is excluded because it's 100% opaque (which has a value of 255). # X1 Y1 X2 Y2 RED GREEN BLUE args . outputs . lines << [ 640 , 0 , 640 , 720 , 0 , 255 , 0 ]","title":"RGBA - Colors and Alpha"},{"location":"04-lines/#hash-advanced","text":"If you want a more readable invocation. You can use the following hash to create a line. Any parameters that are not specified will be given a default value. The keys of the hash can be provided in any order. args . outputs . lines << { x : 0 , y : 0 , x2 : 1280 , y2 : 720 , r : 0 , g : 255 , b : 0 , a : 255 }","title":"Hash (Advanced)"},{"location":"04-lines/#duck-typing-advanced","text":"You can also create a class with line properties and render it as a primitive. ALL properties must on the class. ADDITIONALLY, a method called primitive_marker must be defined on the class. Here is an example: # Create type with ALL line properties AND primitive_marker class Line attr_accessor :x , :y , :x2 , :y2 , :r , :g , :b , :a def primitive_marker :line end end # Inherit from type class VerticalLine < Line # constructor def initialize x , y , h self . x = x self . y = y self . x2 = x self . y2 = y + h end end # render line args . outputs . lines << VerticalLine . new ( 10 , 10 , 100 )","title":"Duck Typing (Advanced)"},{"location":"04-lines/#related-samples","text":"01_api_02_lines 01_api_99_tech_demo (includes recording) 06_coordinate_systems (includes recording) 19_lowrez_jam_01_hello_world 99_sample_game_pong (includes recording)","title":"Related Samples"},{"location":"05-sprites/","text":"This documentation is still under development. Click here to contribute Sprites # Sprites are the most important visual component of a game. Minimum Code # Sprites need to be under the mygame directory. It's recommended that you create a sprites folder to keep things organized. All sprites must be .png files Here is how you create an sprite with located at 100, 100, that is 32 pixels wide and 64 pixels tall. In this example the sprite name is player.png and is located under a directory mygame/sprites . # X Y WIDTH HEIGHT PATH args . outputs . sprites << [ 100 , 100 , 32 , 64 , \"sprites/player.png\" ] Rotation / Angle # Unlike solids and borders , sprites can be rotated. This is how you rotate a sprite 90 degress. Note: All angles in DragonRuby Game Toolkit are represented in degrees (not radians). # X Y WIDTH HEIGHT PATH ANGLE args . outputs . sprites << [ 100 , 100 , 32 , 64 , \"sprites/player.png\" , 90 ] Alpha # Sprites can also have a transparency associated with them. The transparency value must come after the angle value and supports a number between 0 and 255. This is how you would define a sprite with no rotation, and a 50% transparency. # X Y WIDTH HEIGHT PATH ANGLE ALPHA args . outputs . sprites << [ 100 , 100 , 32 , 64 , \"sprites/player.png\" , 0 , 128 ] Color Saturations # A Sprite's color levels can be changed. The color saturations must come after angle and alpha values. This is a sprite with no rotation, fully opaque, and with a green tint. args . outputs . sprites << [ 100 , # X 100 , # Y 32 , # W 64 , # H \"sprites/player.png\" , # PATH 0 , # ANGLE 255 , # ALPHA 0 , # RED_SATURATION 255 , # GREEN_SATURATION 0 ] # BLUE_SATURATION Sprite Sub Division / Tile # You can render a portion of a sprite (a tile). The sub division of the sprite is denoted as a rectangle directly related to the original size of the png. This is a sprite scaled to 100 pixels where the source \"tile\" is located at the bottom left corner within a 32 pixel square. The angle, opacity, and color levels of the tile are unaltered. args . outputs . sprites << [ 100 , # X 100 , # Y 32 , # W 64 , # H \"sprites/player.png\" , # PATH 0 , # ANGLE 255 , # ALPHA 0 , # RED_SATURATION 255 , # GREEN_SATURATION 0 , # BLUE_SATURATION 0 , # TILE_X 0 , # TILE_Y 32 , # TILE_W 32 ] # TILE_H Flipping a Sprite Horizontally and Vertically # A sprite can be flipped horizontally and vertically. This is a sprite that has been flipped horizontally. The sprites's angle, alpha, color saturations, and tile subdivision are unaltered. args . outputs . sprites << [ 100 , # X 100 , # Y 32 , # W 64 , # H \"sprites/player.png\" , # PATH 0 , # ANGLE 255 , # ALPHA 0 , # RED_SATURATION 255 , # GREEN_SATURATION 0 , # BLUE_SATURATION 0 , # TILE_X 0 , # TILE_Y 32 , # TILE_W 32 , # TILE_H true , # FLIP_HORIZONTALLY false ] # FLIP_VERTICALLY This is a sprite that has been flipped vertically. The sprites's angle, alpha, color saturations, and tile subdivision are unaltered. args . outputs . sprites << [ 100 , # X 100 , # Y 32 , # W 64 , # H \"sprites/player.png\" , # PATH 0 , # ANGLE 255 , # ALPHA 0 , # RED_SATURATION 255 , # GREEN_SATURATION 0 , # BLUE_SATURATION 0 , # TILE_X 0 , # TILE_Y 32 , # TILE_W 32 , # TILE_H false , # FLIP_HORIZONTALLY true ] # FLIP_VERTICALLY Rotation Center # A sprites center of rotation can be altered. This is a sprite that has its rotation center set to the top-middle. The sprites's angle, alpha, color saturations, tile subdivision, and projectsions are unaltered. args . outputs . sprites << [ 100 , # X 100 , # Y 32 , # W 64 , # H \"sprites/player.png\" , # PATH 0 , # ANGLE 255 , # ALPHA 255 , # RED_SATURATION 255 , # GREEN_SATURATION 0 , # BLUE_SATURATION 0 , # TILE_X 0 , # TILE_Y - 1 , # TILE_W - 1 , # TILE_H false , # FLIP_HORIZONTALLY false , # FLIP_VERTICALLY 0 . 5 , # ANGLE_ANCHOR_X 1 . 0 ] # ANCHOR_Y Hash (Advanced) # If you want a more readable invocation. You can use the following hash to create a sprite. Any parameters that are not specified will be given a default value. The keys of the hash can be provided in any order. args . outputs . sprites << { x : 100 , y : 100 , w : 100 , h : 100 , path : \"sprites/player.png\" , angle : 0 , a , 255 r : 255 , g : 255 , b : 255 , tile_x : 0 , tile_y : 0 , tile_w : - 1 , tile_h : - 1 , flip_vertically : false , flip_horizontally : false , angle_anchor_x : 0 . 5 , angle_anchor_y : 1 . 0 } Duck Typing (Advanced) # You can also create a class with sprite properties and render it as a primitive. ALL properties must on the class. ADDITIONALLY, a method called primitive_marker must be defined on the class. Here is an example: # Create type with ALL sprite properties AND primitive_marker class Sprite attr_accessor :x , :y , :w , :h , :path , :angle , :a , :r , :g , :b , :tile_x , :tile_y , :tile_w , :tile_h , :flip_horizontally , :flip_vertically , :angle_anchor_x , :angle_anchor_y def primitive_marker :sprite end end # Inherit from type class PlayerSprite < Sprite # constructor def initialize x , y , w , h self . x = x self . y = y self . w = w self . h = h self . path = 'sprites/player.png' end end #render player sprite args . outputs . sprites << PlayerSprite . new ( 10 , 10 , 32 , 64 ) Related Samples # 01_api_04_sprites 01_api_99_tech_demo (includes recording) 02_sprite_animation_and_keyboard_input (includes recording) 08_platformer_collisions_metroidvania 09_controller_analog_usage_advanced_sprites 99_sample_game_basic_gorillas (includes recording) 99_sample_game_dueling_starships (includes recording) 99_sample_game_flappy_dragon (includes recording) 99_sample_game_return_of_serenity","title":"Sprites"},{"location":"05-sprites/#sprites","text":"Sprites are the most important visual component of a game.","title":"Sprites"},{"location":"05-sprites/#minimum-code","text":"Sprites need to be under the mygame directory. It's recommended that you create a sprites folder to keep things organized. All sprites must be .png files Here is how you create an sprite with located at 100, 100, that is 32 pixels wide and 64 pixels tall. In this example the sprite name is player.png and is located under a directory mygame/sprites . # X Y WIDTH HEIGHT PATH args . outputs . sprites << [ 100 , 100 , 32 , 64 , \"sprites/player.png\" ]","title":"Minimum Code"},{"location":"05-sprites/#rotation-angle","text":"Unlike solids and borders , sprites can be rotated. This is how you rotate a sprite 90 degress. Note: All angles in DragonRuby Game Toolkit are represented in degrees (not radians). # X Y WIDTH HEIGHT PATH ANGLE args . outputs . sprites << [ 100 , 100 , 32 , 64 , \"sprites/player.png\" , 90 ]","title":"Rotation / Angle"},{"location":"05-sprites/#alpha","text":"Sprites can also have a transparency associated with them. The transparency value must come after the angle value and supports a number between 0 and 255. This is how you would define a sprite with no rotation, and a 50% transparency. # X Y WIDTH HEIGHT PATH ANGLE ALPHA args . outputs . sprites << [ 100 , 100 , 32 , 64 , \"sprites/player.png\" , 0 , 128 ]","title":"Alpha"},{"location":"05-sprites/#color-saturations","text":"A Sprite's color levels can be changed. The color saturations must come after angle and alpha values. This is a sprite with no rotation, fully opaque, and with a green tint. args . outputs . sprites << [ 100 , # X 100 , # Y 32 , # W 64 , # H \"sprites/player.png\" , # PATH 0 , # ANGLE 255 , # ALPHA 0 , # RED_SATURATION 255 , # GREEN_SATURATION 0 ] # BLUE_SATURATION","title":"Color Saturations"},{"location":"05-sprites/#sprite-sub-division-tile","text":"You can render a portion of a sprite (a tile). The sub division of the sprite is denoted as a rectangle directly related to the original size of the png. This is a sprite scaled to 100 pixels where the source \"tile\" is located at the bottom left corner within a 32 pixel square. The angle, opacity, and color levels of the tile are unaltered. args . outputs . sprites << [ 100 , # X 100 , # Y 32 , # W 64 , # H \"sprites/player.png\" , # PATH 0 , # ANGLE 255 , # ALPHA 0 , # RED_SATURATION 255 , # GREEN_SATURATION 0 , # BLUE_SATURATION 0 , # TILE_X 0 , # TILE_Y 32 , # TILE_W 32 ] # TILE_H","title":"Sprite Sub Division / Tile"},{"location":"05-sprites/#flipping-a-sprite-horizontally-and-vertically","text":"A sprite can be flipped horizontally and vertically. This is a sprite that has been flipped horizontally. The sprites's angle, alpha, color saturations, and tile subdivision are unaltered. args . outputs . sprites << [ 100 , # X 100 , # Y 32 , # W 64 , # H \"sprites/player.png\" , # PATH 0 , # ANGLE 255 , # ALPHA 0 , # RED_SATURATION 255 , # GREEN_SATURATION 0 , # BLUE_SATURATION 0 , # TILE_X 0 , # TILE_Y 32 , # TILE_W 32 , # TILE_H true , # FLIP_HORIZONTALLY false ] # FLIP_VERTICALLY This is a sprite that has been flipped vertically. The sprites's angle, alpha, color saturations, and tile subdivision are unaltered. args . outputs . sprites << [ 100 , # X 100 , # Y 32 , # W 64 , # H \"sprites/player.png\" , # PATH 0 , # ANGLE 255 , # ALPHA 0 , # RED_SATURATION 255 , # GREEN_SATURATION 0 , # BLUE_SATURATION 0 , # TILE_X 0 , # TILE_Y 32 , # TILE_W 32 , # TILE_H false , # FLIP_HORIZONTALLY true ] # FLIP_VERTICALLY","title":"Flipping a Sprite Horizontally and Vertically"},{"location":"05-sprites/#rotation-center","text":"A sprites center of rotation can be altered. This is a sprite that has its rotation center set to the top-middle. The sprites's angle, alpha, color saturations, tile subdivision, and projectsions are unaltered. args . outputs . sprites << [ 100 , # X 100 , # Y 32 , # W 64 , # H \"sprites/player.png\" , # PATH 0 , # ANGLE 255 , # ALPHA 255 , # RED_SATURATION 255 , # GREEN_SATURATION 0 , # BLUE_SATURATION 0 , # TILE_X 0 , # TILE_Y - 1 , # TILE_W - 1 , # TILE_H false , # FLIP_HORIZONTALLY false , # FLIP_VERTICALLY 0 . 5 , # ANGLE_ANCHOR_X 1 . 0 ] # ANCHOR_Y","title":"Rotation Center"},{"location":"05-sprites/#hash-advanced","text":"If you want a more readable invocation. You can use the following hash to create a sprite. Any parameters that are not specified will be given a default value. The keys of the hash can be provided in any order. args . outputs . sprites << { x : 100 , y : 100 , w : 100 , h : 100 , path : \"sprites/player.png\" , angle : 0 , a , 255 r : 255 , g : 255 , b : 255 , tile_x : 0 , tile_y : 0 , tile_w : - 1 , tile_h : - 1 , flip_vertically : false , flip_horizontally : false , angle_anchor_x : 0 . 5 , angle_anchor_y : 1 . 0 }","title":"Hash (Advanced)"},{"location":"05-sprites/#duck-typing-advanced","text":"You can also create a class with sprite properties and render it as a primitive. ALL properties must on the class. ADDITIONALLY, a method called primitive_marker must be defined on the class. Here is an example: # Create type with ALL sprite properties AND primitive_marker class Sprite attr_accessor :x , :y , :w , :h , :path , :angle , :a , :r , :g , :b , :tile_x , :tile_y , :tile_w , :tile_h , :flip_horizontally , :flip_vertically , :angle_anchor_x , :angle_anchor_y def primitive_marker :sprite end end # Inherit from type class PlayerSprite < Sprite # constructor def initialize x , y , w , h self . x = x self . y = y self . w = w self . h = h self . path = 'sprites/player.png' end end #render player sprite args . outputs . sprites << PlayerSprite . new ( 10 , 10 , 32 , 64 )","title":"Duck Typing (Advanced)"},{"location":"05-sprites/#related-samples","text":"01_api_04_sprites 01_api_99_tech_demo (includes recording) 02_sprite_animation_and_keyboard_input (includes recording) 08_platformer_collisions_metroidvania 09_controller_analog_usage_advanced_sprites 99_sample_game_basic_gorillas (includes recording) 99_sample_game_dueling_starships (includes recording) 99_sample_game_flappy_dragon (includes recording) 99_sample_game_return_of_serenity","title":"Related Samples"},{"location":"06-keyboard/","text":"This documentation is still under development. Click here to contribute Keyboard # Determining if a key is in the down state (pressed). This happens once each time the key is pressed: if args.inputs.keyboard.key_down.a puts 'The key is pressed' end Determining if a key is being held. This happens every tick while the key is held down: if args.inputs.keyboard.key_held.a puts 'The key is being held' end Determining if a key is in the down state or is being held: if args.inputs.keyboard.a puts 'The key is pressed or being held' end Determining if a key is in the up state (released). This happens once each time the key is released: if args.inputs.keyboard.key_up.a puts 'The key is released' end Truthy Keys # You can access all triggered keys through truthy_keys on keyboard , controller_one , and controller_two . This is how you would right all keys to a file. The game must be in the foreground and have focus for this data to be recorded. def tick args [ [args.inputs.keyboard, :keyboard], [args.inputs.controller_one, :controller_one], [args.inputs.controller_two, :controller_two] ].each do |input, name| if input.key_down.truthy_keys.length > 0 args.gtk.write_file(\"mygame/app/#{name}_key_down_#{args.state.tick_count}\", input.key_down.truthy_keys.to_s) end end end List of keys: # These are the character and associated properities that will be set to true. For example A => :a, :shift means that args.inputs.keyboard.a would be true and so would args.inputs.keyboard.shift (if both keys were being held or in the down state). A => :a, :shift B => :b, :shift C => :c, :shift D => :d, :shift E => :e, :shift F => :f, :shift G => :g, :shift H => :h, :shift I => :i, :shift J => :j, :shift K => :k, :shift L => :l, :shift M => :m, :shift N => :n, :shift O => :o, :shift P => :p, :shift Q => :q, :shift R => :r, :shift S => :s, :shift T => :t, :shift U => :u, :shift V => :v, :shift W => :w, :shift X => :x, :shift Y => :y, :shift Z => :z, :shift ! => :exclamation_point 0 => :zero 1 => :one 2 => :two 3 => :three 4 => :four 5 => :five 6 => :six 7 => :seven 8 => :eight 9 => :nine \\ b = > : backspace \\ e = > : escape \\ r = > : enter \\ t = > : tab ( = > : open_round_brace ) = > : close_round_brace { = > : open_curly_brace } = > : close_curly_brace [ = > : open_square_brace ] = > : close_square_brace : = > : colon ; = > : semicolon = = > : equal_sign - = > : hyphen = > : space $ = > : dollar_sign \" = > : double_quotation_mark ' => :single_quotation_mark ` = > : backtick ~ = > : tilde . = > : period , = > : comma | = > : pipe _ => :underscore # = > : hash + = > : plus @ = > : at / = > : forward_slash \\ = > : back_slash * = > : asterisk < = > : less_than > = > : greater_than ^ = > : greater_than & = > : ampersand \u00b2 => :superscript_two \u00a7 = > : section_sign ? = > : question_mark % => :percent_sign \u00ba => :ordinal_indicator right arrow => :right left arrow => :left down arrow => :down up arrow => :up delete key => :delete control key => :control windows key/command key => :meta alt key => :alt","title":"Keyboard"},{"location":"06-keyboard/#keyboard","text":"Determining if a key is in the down state (pressed). This happens once each time the key is pressed: if args.inputs.keyboard.key_down.a puts 'The key is pressed' end Determining if a key is being held. This happens every tick while the key is held down: if args.inputs.keyboard.key_held.a puts 'The key is being held' end Determining if a key is in the down state or is being held: if args.inputs.keyboard.a puts 'The key is pressed or being held' end Determining if a key is in the up state (released). This happens once each time the key is released: if args.inputs.keyboard.key_up.a puts 'The key is released' end","title":"Keyboard"},{"location":"06-keyboard/#truthy-keys","text":"You can access all triggered keys through truthy_keys on keyboard , controller_one , and controller_two . This is how you would right all keys to a file. The game must be in the foreground and have focus for this data to be recorded. def tick args [ [args.inputs.keyboard, :keyboard], [args.inputs.controller_one, :controller_one], [args.inputs.controller_two, :controller_two] ].each do |input, name| if input.key_down.truthy_keys.length > 0 args.gtk.write_file(\"mygame/app/#{name}_key_down_#{args.state.tick_count}\", input.key_down.truthy_keys.to_s) end end end","title":"Truthy Keys"},{"location":"06-keyboard/#list-of-keys","text":"These are the character and associated properities that will be set to true. For example A => :a, :shift means that args.inputs.keyboard.a would be true and so would args.inputs.keyboard.shift (if both keys were being held or in the down state). A => :a, :shift B => :b, :shift C => :c, :shift D => :d, :shift E => :e, :shift F => :f, :shift G => :g, :shift H => :h, :shift I => :i, :shift J => :j, :shift K => :k, :shift L => :l, :shift M => :m, :shift N => :n, :shift O => :o, :shift P => :p, :shift Q => :q, :shift R => :r, :shift S => :s, :shift T => :t, :shift U => :u, :shift V => :v, :shift W => :w, :shift X => :x, :shift Y => :y, :shift Z => :z, :shift ! => :exclamation_point 0 => :zero 1 => :one 2 => :two 3 => :three 4 => :four 5 => :five 6 => :six 7 => :seven 8 => :eight 9 => :nine \\ b = > : backspace \\ e = > : escape \\ r = > : enter \\ t = > : tab ( = > : open_round_brace ) = > : close_round_brace { = > : open_curly_brace } = > : close_curly_brace [ = > : open_square_brace ] = > : close_square_brace : = > : colon ; = > : semicolon = = > : equal_sign - = > : hyphen = > : space $ = > : dollar_sign \" = > : double_quotation_mark ' => :single_quotation_mark ` = > : backtick ~ = > : tilde . = > : period , = > : comma | = > : pipe _ => :underscore # = > : hash + = > : plus @ = > : at / = > : forward_slash \\ = > : back_slash * = > : asterisk < = > : less_than > = > : greater_than ^ = > : greater_than & = > : ampersand \u00b2 => :superscript_two \u00a7 = > : section_sign ? = > : question_mark % => :percent_sign \u00ba => :ordinal_indicator right arrow => :right left arrow => :left down arrow => :down up arrow => :up delete key => :delete control key => :control windows key/command key => :meta alt key => :alt","title":"List of keys:"},{"location":"07-mouse/","text":"This documentation is still under development. Click here to contribute Mouse # Determining current position of mouse: args.inputs.mouse.x args.inputs.mouse.y Determining if the mouse has been clicked, and it's position. Note: click and down are aliases for each other. if args.inputs.mouse.click puts \"click: #{args.inputs.mouse.click}\" puts \"x: #{args.inputs.mouse.click.point.x}\" puts \"y: #{args.inputs.mouse.click.point.y}\" end Determining if the mouse button has been released: if args.inputs.mouse.up puts \"up: #{args.inputs.mouse.up}\" puts \"x: #{args.inputs.mouse.up.point.x}\" puts \"y: #{args.inputs.mouse.up.point.y}\" end Determine which mouse button(s) have been clicked (also works for up): if args.inputs.mouse.click puts \"left: #{args.inputs.mouse.button_left}\" puts \"middle: #{args.inputs.mouse.button_middle}\" puts \"right: #{args.inputs.mouse.button_right}\" puts \"x1: #{args.inputs.mouse.button_x1}\" puts \"x2: #{args.inputs.mouse.button_x2}\" end Determine if the mouse wheel is being used and its values for this tick: if args.inputs.mouse.wheel puts \"The wheel moved #{args.inputs.mouse.wheel.x} left/right\" puts \"The wheel moved #{args.inputs.mouse.wheel.y} up/down\" end","title":"Mouse"},{"location":"07-mouse/#mouse","text":"Determining current position of mouse: args.inputs.mouse.x args.inputs.mouse.y Determining if the mouse has been clicked, and it's position. Note: click and down are aliases for each other. if args.inputs.mouse.click puts \"click: #{args.inputs.mouse.click}\" puts \"x: #{args.inputs.mouse.click.point.x}\" puts \"y: #{args.inputs.mouse.click.point.y}\" end Determining if the mouse button has been released: if args.inputs.mouse.up puts \"up: #{args.inputs.mouse.up}\" puts \"x: #{args.inputs.mouse.up.point.x}\" puts \"y: #{args.inputs.mouse.up.point.y}\" end Determine which mouse button(s) have been clicked (also works for up): if args.inputs.mouse.click puts \"left: #{args.inputs.mouse.button_left}\" puts \"middle: #{args.inputs.mouse.button_middle}\" puts \"right: #{args.inputs.mouse.button_right}\" puts \"x1: #{args.inputs.mouse.button_x1}\" puts \"x2: #{args.inputs.mouse.button_x2}\" end Determine if the mouse wheel is being used and its values for this tick: if args.inputs.mouse.wheel puts \"The wheel moved #{args.inputs.mouse.wheel.x} left/right\" puts \"The wheel moved #{args.inputs.mouse.wheel.y} up/down\" end","title":"Mouse"},{"location":"08-controllers/","text":"This documentation is still under development. Click here to contribute Controllers # There are two controllers you have access to: args.inputs.controller_one args.inputs.controller_two Determining if a key was down: if args.inputs.controller_one.key_down.a puts 'The key was in the down state' end Determining if a key is being held: if args.inputs.controller_one.key_held.a puts 'The key is being held' end Determining if a key is released: if args.inputs.controller_one.key_up.a puts 'The key is being held' end Truthy Keys # You can access all triggered keys through thruthy_keys on keyboard , controller_one , and controller_two . This is how you would right all keys to a file. The game must be in the foreground and have focus for this data to be recorded. def tick args [ [args.inputs.keyboard, :keyboard], [args.inputs.controller_one, :controller_one], [args.inputs.controller_two, :controller_two] ].each do |input, name| if input.key_down.truthy_keys.length > 0 args.gtk.write_file(\"mygame/app/#{name}_key_down_#{args.state.tick_count}\", input.key_down.truthy_keys.to_s) end end end List of keys: # args.inputs.controller_one.key_held.up args.inputs.controller_one.key_held.down args.inputs.controller_one.key_held.left args.inputs.controller_one.key_held.right args.inputs.controller_one.key_held.a args.inputs.controller_one.key_held.b args.inputs.controller_one.x args.inputs.controller_one.y args.inputs.controller_one.key_held.l1 args.inputs.controller_one.key_held.r1 args.inputs.controller_one.key_held.l2 args.inputs.controller_one.key_held.r2 args.inputs.controller_one.key_held.l3 args.inputs.controller_one.key_held.r3 args.inputs.controller_one.key_held.start args.inputs.controller_one.key_held.select args.inputs.controller_one.key_held.directional_up args.inputs.controller_one.key_held.directional_down args.inputs.controller_one.key_held.directional_left args.inputs.controller_one.key_held.directional_right args.inputs.controller_one.left_analog_x_raw, args.inputs.controller_one.left_analog_y_raw, args.inputs.controller_one.left_analog_x_perc, args.inputs.controller_one.left_analog_y_perc, args.inputs.controller_one.right_analog_x_raw, args.inputs.controller_one.right_analog_y_raw, args.inputs.controller_one.right_analog_x_perc, args.inputs.controller_one.right_analog_y_perc","title":"Controllers"},{"location":"08-controllers/#controllers","text":"There are two controllers you have access to: args.inputs.controller_one args.inputs.controller_two Determining if a key was down: if args.inputs.controller_one.key_down.a puts 'The key was in the down state' end Determining if a key is being held: if args.inputs.controller_one.key_held.a puts 'The key is being held' end Determining if a key is released: if args.inputs.controller_one.key_up.a puts 'The key is being held' end","title":"Controllers"},{"location":"08-controllers/#truthy-keys","text":"You can access all triggered keys through thruthy_keys on keyboard , controller_one , and controller_two . This is how you would right all keys to a file. The game must be in the foreground and have focus for this data to be recorded. def tick args [ [args.inputs.keyboard, :keyboard], [args.inputs.controller_one, :controller_one], [args.inputs.controller_two, :controller_two] ].each do |input, name| if input.key_down.truthy_keys.length > 0 args.gtk.write_file(\"mygame/app/#{name}_key_down_#{args.state.tick_count}\", input.key_down.truthy_keys.to_s) end end end","title":"Truthy Keys"},{"location":"08-controllers/#list-of-keys","text":"args.inputs.controller_one.key_held.up args.inputs.controller_one.key_held.down args.inputs.controller_one.key_held.left args.inputs.controller_one.key_held.right args.inputs.controller_one.key_held.a args.inputs.controller_one.key_held.b args.inputs.controller_one.x args.inputs.controller_one.y args.inputs.controller_one.key_held.l1 args.inputs.controller_one.key_held.r1 args.inputs.controller_one.key_held.l2 args.inputs.controller_one.key_held.r2 args.inputs.controller_one.key_held.l3 args.inputs.controller_one.key_held.r3 args.inputs.controller_one.key_held.start args.inputs.controller_one.key_held.select args.inputs.controller_one.key_held.directional_up args.inputs.controller_one.key_held.directional_down args.inputs.controller_one.key_held.directional_left args.inputs.controller_one.key_held.directional_right args.inputs.controller_one.left_analog_x_raw, args.inputs.controller_one.left_analog_y_raw, args.inputs.controller_one.left_analog_x_perc, args.inputs.controller_one.left_analog_y_perc, args.inputs.controller_one.right_analog_x_raw, args.inputs.controller_one.right_analog_y_raw, args.inputs.controller_one.right_analog_x_perc, args.inputs.controller_one.right_analog_y_perc","title":"List of keys:"},{"location":"09-sound/","text":"This documentation is still under development. Click here to contribute MP3's to Wav converstion script: # `ls .` . each_line . to_a . map do | l | l = l . strip if l . end_with? \"mp3\" `ffmpeg -i #{ l } -acodec pcm_s16le -ar 44100 prep- #{ l . split ( \".\" ) [ 0 ] } .wav` `ffmpeg -y -i prep- #{ l . split ( \".\" ) [ 0 ] } .wav -f wav -bitexact -acodec pcm_s16le -ar 44100 -ac 1 #{ l . split ( \".\" ) [ 0 ] } .wav` end end","title":"Sounds"},{"location":"09-sound/#mp3s-to-wav-converstion-script","text":"`ls .` . each_line . to_a . map do | l | l = l . strip if l . end_with? \"mp3\" `ffmpeg -i #{ l } -acodec pcm_s16le -ar 44100 prep- #{ l . split ( \".\" ) [ 0 ] } .wav` `ffmpeg -y -i prep- #{ l . split ( \".\" ) [ 0 ] } .wav -f wav -bitexact -acodec pcm_s16le -ar 44100 -ac 1 #{ l . split ( \".\" ) [ 0 ] } .wav` end end","title":"MP3's to Wav converstion script:"},{"location":"10-entities-and-collisions/","text":"This documentation is still under development. Click here to contribute Entities and Collision # Randomly create 500 ninjas on the screen. Create a lookup table that contains the alpha property of ninjas that have collided. Present all ninjas with their alpha properties set. def tick args # destructure args into local variables grid , state , outputs = args . grid , args . state , args . outputs # use Game Toolkit's built in helper methods to create # adhoc entities state . ninjas ||= 500 . map do state . new_entity ( :ninja , { rect : [ grid . w . - ( 50 ) * rand , grid . h . - ( 50 ) * rand , 50 , 50 ] }) end # use Ruby's powerful apis to determine collision state . collisions ||= state . ninja . product . reject { | n , n2 | n == n2 } . find_all { | n , n2 | n . rect . intersects_rect? ( n2 . rect ) } . map { | n , _ | [ n . entity_id , 128 ] } . pairs_to_hash #render everything to the screen outputs . sprites << state . ninjas . map do | n | [ n . rect , 'dragonruby.png' , 0 , state . collisions [ n . entity_id ] || 255 ] end end","title":"Entities & Collisions"},{"location":"10-entities-and-collisions/#entities-and-collision","text":"Randomly create 500 ninjas on the screen. Create a lookup table that contains the alpha property of ninjas that have collided. Present all ninjas with their alpha properties set. def tick args # destructure args into local variables grid , state , outputs = args . grid , args . state , args . outputs # use Game Toolkit's built in helper methods to create # adhoc entities state . ninjas ||= 500 . map do state . new_entity ( :ninja , { rect : [ grid . w . - ( 50 ) * rand , grid . h . - ( 50 ) * rand , 50 , 50 ] }) end # use Ruby's powerful apis to determine collision state . collisions ||= state . ninja . product . reject { | n , n2 | n == n2 } . find_all { | n , n2 | n . rect . intersects_rect? ( n2 . rect ) } . map { | n , _ | [ n . entity_id , 128 ] } . pairs_to_hash #render everything to the screen outputs . sprites << state . ninjas . map do | n | [ n . rect , 'dragonruby.png' , 0 , state . collisions [ n . entity_id ] || 255 ] end end","title":"Entities and Collision"},{"location":"11-commands/","text":"This documentation is still under development. Click here to contribute Commands # Below is an ever growing list of commands available for DragonRuby GTK. Args # Class: (class Object)::(class GTK::Args) args Method Description borders TBD clear_render_targets TBD click TBD click_at TBD controller_one TBD controller_two TBD destructure TBD dragon TBD game TBD grid TBD grid= TBD gtk TBD initialize TBD inputs TBD inputs= TBD keyboard TBD labels TBD lines TBD mouse TBD outputs TBD outputs= TBD passes TBD passes= TBD primitives TBD recording TBD recording= TBD render_target TBD runtime TBD runtime= TBD serialize TBD solids TBD sprites TBD state TBD state= TBD static_borders TBD static_labels TBD static_lines TBD static_primitives TBD static_solids TBD static_sprites TBD Inputs # args.input Method Description controller_one TBD controller_two TBD controllers TBD controllers= TBD history TBD history= TBD initialize TBD keyboard TBD keyboard= TBD mouse TBD mouse= TBD serialize TBD text TBD text= TBD Controller_One # args.inputs.controller_one Method Description clear TBD initialize TBD key_down TBD key_down= TBD key_held TBD key_held= TBD key_up TBD key_up= TBD left_analog_x_perc TBD left_analog_x_perc= TBD left_analog_x_raw TBD left_analog_x_raw= TBD left_analog_y_perc TBD left_analog_y_perc= TBD left_analog_y_raw TBD left_analog_y_raw= TBD left_right TBD left_right= TBD right_analog_x_perc TBD right_analog_x_perc= TBD right_analog_x_raw TBD right_analog_x_raw= TBD right_analog_y_perc TBD right_analog_y_perc= TBD right_analog_y_raw TBD right_analog_y_raw= TBD serialize TBD up_down TBD up_down= TBD Controller_Two # args.inputs.controller_two Method Description clear TBD initialize TBD key_down TBD key_down= TBD key_held TBD key_held= TBD key_up TBD key_up= TBD left_analog_x_perc TBD left_analog_x_perc= TBD left_analog_x_raw TBD left_analog_x_raw= TBD left_analog_y_perc TBD left_analog_y_perc= TBD left_analog_y_raw TBD left_analog_y_raw= TBD left_right TBD left_right= TBD right_analog_x_perc TBD right_analog_x_perc= TBD right_analog_x_raw TBD right_analog_x_raw= TBD right_analog_y_perc TBD right_analog_y_perc= TBD right_analog_y_raw TBD right_analog_y_raw= TBD serialize TBD up_down TBD up_down= TBD Keyboard # args.inputs.keyboard Method Description clear TBD down TBD has_focus TBD has_focus= TBD initialize TBD inspect TBD key_down TBD key_down= TBD key_held TBD key_held= TBD key_up TBD key_up= TBD left TBD left_right TBD right TBD serialize TBD to_s TBD up TBD up_down TBD Mouse # args.inputs.mouse Method Description clear TBD click TBD click= TBD down TBD has_focus TBD has_focus= TBD initialize TBD moved TBD moved= TBD moved_at TBD moved_at= TBD moved_at_time TBD moved_at_time= TBD position TBD previous_click TBD previous_click= TBD serialize TBD up TBD up= TBD x TBD x= TBD y TBD y= TBD Grid # args.grid Method Description __print_origin_help TBD bottom TBD bottom= TBD center_x TBD center_x= TBD center_y TBD center_y= TBD h TBD h_half TBD initialize TBD left TBD left= TBD name TBD name= TBD origin_bottom_left! TBD origin_center! TBD origin_x TBD origin_x= TBD origin_y TBD origin_y= TBD rect TBD rect= TBD right TBD right= TBD top TBD top= TBD transform_angle TBD transform_rect TBD transform_x TBD transform_y TBD untransform_x TBD untransform_y TBD w TBD w_half TBD Outputs # Args.Outputs Method Description __borders= TBD __labels= TBD __lines= TBD __primitives= TBD __raise_deprecated__ TBD __reserved= TBD __solids= TBD __sprites= TBD __static_borders= TBD __static_labels= TBD __static_lines= TBD __static_primitives= TBD __static_reserved= TBD __static_solids= TBD __static_sprites= TBD all_borders TBD all_labels TBD all_lines TBD all_primitives TBD all_reserved TBD all_solids TBD all_sounds TBD all_sprites TBD borders TBD borders= TBD clear TBD clear_non_static TBD height TBD height= TBD initialize TBD labels TBD labels= TBD lines TBD lines= TBD primitives TBD primitives= TBD reserved TBD reserved= TBD serialize TBD solids TBD solids= TBD sounds TBD sounds= TBD sprites TBD sprites= TBD static_borders TBD static_borders= TBD static_labels TBD static_labels= TBD static_lines TBD static_lines= TBD static_primitives TBD static_primitives= TBD static_reserved TBD static_reserved= TBD static_solids TBD static_solids= TBD static_sprites TBD static_sprites= TBD target TBD target= TBD tick TBD width TBD width= TBD Labels # Args.Outputs.Labels Option (bold denotes mandatory) Description x ** Location on X-Axis** y ** Location on Y-Axis** text ** Text to display** size_enum Default : 0 . Positive values increase the label size Negative values decrease the label size.. alignment_enum Default (Left Aligned): 0 Center Aligned: 1 Right Aligned: 2 r Red value (0-255) g Green value (0-255) b Blue value (0-255 a Alpha value (0-255) font Location of font file State # Class: (class Object)::(class GTK::OpenEntity) args.state Method Description |==| tbd __contains_array_indexers__ tbd __contains_array_indexers__ = tbd __get_hash_property__ tbd __meta__ tbd __reserved_keys__ tbd __set_hash_property__ tbd __touched__ tbd __touched__ = tbd attributes tbd clear! tbd created_at_elapsed tbd documenter_success tbd entity_id tbd global_created_at_elapsed tbd hash tbd initialize tbd inspect tbd meta tbd meta! tbd method_missing tbd new? tbd new_entity tbd new_entity_strict tbd old? tbd original_eq_eq tbd set! tbd tick_count= tbd to_s tbd with_meta tbd New Entity # Class: (class Object)::(class GTK::OpenEntity) args.state.new_entity Method Description == TBD contains_array_indexers TBD contains_array_indexers = TBD get_hash_property TBD meta TBD reserved_keys TBD set_hash_property TBD touched TBD touched = TBD attributes TBD clear! TBD created_at= TBD created_at_elapsed TBD entity_id TBD entity_type= TBD global_created_at= TBD global_created_at_elapsed TBD hash TBD initialize TBD inspect TBD meta TBD meta! TBD method_missing TBD new? TBD new_entity TBD new_entity_strict TBD old? TBD original_eq_eq TBD set! TBD to_s TBD with_meta TBD","title":"Commands"},{"location":"11-commands/#commands","text":"Below is an ever growing list of commands available for DragonRuby GTK.","title":"Commands"},{"location":"11-commands/#args","text":"Class: (class Object)::(class GTK::Args) args Method Description borders TBD clear_render_targets TBD click TBD click_at TBD controller_one TBD controller_two TBD destructure TBD dragon TBD game TBD grid TBD grid= TBD gtk TBD initialize TBD inputs TBD inputs= TBD keyboard TBD labels TBD lines TBD mouse TBD outputs TBD outputs= TBD passes TBD passes= TBD primitives TBD recording TBD recording= TBD render_target TBD runtime TBD runtime= TBD serialize TBD solids TBD sprites TBD state TBD state= TBD static_borders TBD static_labels TBD static_lines TBD static_primitives TBD static_solids TBD static_sprites TBD","title":"Args"},{"location":"11-commands/#inputs","text":"args.input Method Description controller_one TBD controller_two TBD controllers TBD controllers= TBD history TBD history= TBD initialize TBD keyboard TBD keyboard= TBD mouse TBD mouse= TBD serialize TBD text TBD text= TBD","title":"Inputs"},{"location":"11-commands/#controller_one","text":"args.inputs.controller_one Method Description clear TBD initialize TBD key_down TBD key_down= TBD key_held TBD key_held= TBD key_up TBD key_up= TBD left_analog_x_perc TBD left_analog_x_perc= TBD left_analog_x_raw TBD left_analog_x_raw= TBD left_analog_y_perc TBD left_analog_y_perc= TBD left_analog_y_raw TBD left_analog_y_raw= TBD left_right TBD left_right= TBD right_analog_x_perc TBD right_analog_x_perc= TBD right_analog_x_raw TBD right_analog_x_raw= TBD right_analog_y_perc TBD right_analog_y_perc= TBD right_analog_y_raw TBD right_analog_y_raw= TBD serialize TBD up_down TBD up_down= TBD","title":"Controller_One"},{"location":"11-commands/#controller_two","text":"args.inputs.controller_two Method Description clear TBD initialize TBD key_down TBD key_down= TBD key_held TBD key_held= TBD key_up TBD key_up= TBD left_analog_x_perc TBD left_analog_x_perc= TBD left_analog_x_raw TBD left_analog_x_raw= TBD left_analog_y_perc TBD left_analog_y_perc= TBD left_analog_y_raw TBD left_analog_y_raw= TBD left_right TBD left_right= TBD right_analog_x_perc TBD right_analog_x_perc= TBD right_analog_x_raw TBD right_analog_x_raw= TBD right_analog_y_perc TBD right_analog_y_perc= TBD right_analog_y_raw TBD right_analog_y_raw= TBD serialize TBD up_down TBD up_down= TBD","title":"Controller_Two"},{"location":"11-commands/#keyboard","text":"args.inputs.keyboard Method Description clear TBD down TBD has_focus TBD has_focus= TBD initialize TBD inspect TBD key_down TBD key_down= TBD key_held TBD key_held= TBD key_up TBD key_up= TBD left TBD left_right TBD right TBD serialize TBD to_s TBD up TBD up_down TBD","title":"Keyboard"},{"location":"11-commands/#mouse","text":"args.inputs.mouse Method Description clear TBD click TBD click= TBD down TBD has_focus TBD has_focus= TBD initialize TBD moved TBD moved= TBD moved_at TBD moved_at= TBD moved_at_time TBD moved_at_time= TBD position TBD previous_click TBD previous_click= TBD serialize TBD up TBD up= TBD x TBD x= TBD y TBD y= TBD","title":"Mouse"},{"location":"11-commands/#grid","text":"args.grid Method Description __print_origin_help TBD bottom TBD bottom= TBD center_x TBD center_x= TBD center_y TBD center_y= TBD h TBD h_half TBD initialize TBD left TBD left= TBD name TBD name= TBD origin_bottom_left! TBD origin_center! TBD origin_x TBD origin_x= TBD origin_y TBD origin_y= TBD rect TBD rect= TBD right TBD right= TBD top TBD top= TBD transform_angle TBD transform_rect TBD transform_x TBD transform_y TBD untransform_x TBD untransform_y TBD w TBD w_half TBD","title":"Grid"},{"location":"11-commands/#outputs","text":"Args.Outputs Method Description __borders= TBD __labels= TBD __lines= TBD __primitives= TBD __raise_deprecated__ TBD __reserved= TBD __solids= TBD __sprites= TBD __static_borders= TBD __static_labels= TBD __static_lines= TBD __static_primitives= TBD __static_reserved= TBD __static_solids= TBD __static_sprites= TBD all_borders TBD all_labels TBD all_lines TBD all_primitives TBD all_reserved TBD all_solids TBD all_sounds TBD all_sprites TBD borders TBD borders= TBD clear TBD clear_non_static TBD height TBD height= TBD initialize TBD labels TBD labels= TBD lines TBD lines= TBD primitives TBD primitives= TBD reserved TBD reserved= TBD serialize TBD solids TBD solids= TBD sounds TBD sounds= TBD sprites TBD sprites= TBD static_borders TBD static_borders= TBD static_labels TBD static_labels= TBD static_lines TBD static_lines= TBD static_primitives TBD static_primitives= TBD static_reserved TBD static_reserved= TBD static_solids TBD static_solids= TBD static_sprites TBD static_sprites= TBD target TBD target= TBD tick TBD width TBD width= TBD","title":"Outputs"},{"location":"11-commands/#labels","text":"Args.Outputs.Labels Option (bold denotes mandatory) Description x ** Location on X-Axis** y ** Location on Y-Axis** text ** Text to display** size_enum Default : 0 . Positive values increase the label size Negative values decrease the label size.. alignment_enum Default (Left Aligned): 0 Center Aligned: 1 Right Aligned: 2 r Red value (0-255) g Green value (0-255) b Blue value (0-255 a Alpha value (0-255) font Location of font file","title":"Labels"},{"location":"11-commands/#state","text":"Class: (class Object)::(class GTK::OpenEntity) args.state Method Description |==| tbd __contains_array_indexers__ tbd __contains_array_indexers__ = tbd __get_hash_property__ tbd __meta__ tbd __reserved_keys__ tbd __set_hash_property__ tbd __touched__ tbd __touched__ = tbd attributes tbd clear! tbd created_at_elapsed tbd documenter_success tbd entity_id tbd global_created_at_elapsed tbd hash tbd initialize tbd inspect tbd meta tbd meta! tbd method_missing tbd new? tbd new_entity tbd new_entity_strict tbd old? tbd original_eq_eq tbd set! tbd tick_count= tbd to_s tbd with_meta tbd","title":"State"},{"location":"11-commands/#new-entity","text":"Class: (class Object)::(class GTK::OpenEntity) args.state.new_entity Method Description == TBD contains_array_indexers TBD contains_array_indexers = TBD get_hash_property TBD meta TBD reserved_keys TBD set_hash_property TBD touched TBD touched = TBD attributes TBD clear! TBD created_at= TBD created_at_elapsed TBD entity_id TBD entity_type= TBD global_created_at= TBD global_created_at_elapsed TBD hash TBD initialize TBD inspect TBD meta TBD meta! TBD method_missing TBD new? TBD new_entity TBD new_entity_strict TBD old? TBD original_eq_eq TBD set! TBD to_s TBD with_meta TBD","title":"New Entity"},{"location":"97-cheatsheet/","text":"This documentation is still under development. Click here to contribute DragonRuby Game Toolkit Cheatsheet # A detailed documentation listing is located at mygame/documentation . For real world sample usages of GTK's APIs, take a look at the samples directory. The sample apps are ordered by beginner to advanced. So look at them in order to get the most out of them. Minimum Code for Game # The minimum amount of code required for a game is a file named mygame/main.rb with the following: def tick args args . outputs . labels << [ 640 , 360 , \"Hello World\" ] end Args: args # All of GTK's functionality hangs off of args . Args' Outputs: args.outputs # All render primitive s are accessible under args.outputs . Labels: args.outputs.labels # args.outputs.labels is used to render labels. Labels are how you display text. This code will go directly inside of the def tick args method. - Minimum Code # # # X Y TEXT args . outputs . labels << [ 640 , 360 , \"I am a black label.\" ] - A Colored Label # # # A colored label # X Y TEXT, RED GREEN BLUE ALPHA args . outputs . labels << [ 640 , 360 , \"I am a redish label.\" , 255 , 128 , 128 , 255 ] - Extended Capabilities # # # A colored label # X Y TEXT SIZE ALIGNMENT RED GREEN BLUE ALPHA FONT FILE args . outputs . labels << [ 640 , 360 , \"Hello world\" , 0 , 1 , 0 , 0 , 0 , 255 , \"fonts/coolfont.ttf\" ] A SIZE of 0 represents \"default size\". A negative value will decrease the label size. A positive value will increase the label's size. An ALIGNMENT of 0 represents \"left aligned\". 1 represents \"center aligned\". 2 represents \"right aligned\". - Named Parameters/Additional Metadata # # You can add additional metadata about your game within a label, which requires you to use a Hash instead. args . outputs . labels << { x : 200 , y : 550 , text : \"dragonruby\" , size_enum : 2 , alignment_enum : 1 , r : 155 , g : 50 , b : 50 , a : 255 , font : \"fonts/manaspc.ttf\" , # You can add any properties you like (this will be ignored/won't cause errors) game_data_one : \"Something\" , game_data_two : { value_1 : \"value\" , value_2 : \"value two\" , a_number : 15 } } Getting The Size of a Piece of Text:# --- args.gtk.calcstringbox def tick args # local variable # TEXT SIZE_ENUM FONT text_size = args . gtk . args . calcstringbox ( \"some string\" , 0 , \"font.ttf\" ) # print size of a label to screen using Ruby's string formatting capabilities: #{} args . outputs . labels << [ 640 , 360 , \"the label's size is: #{ text_size . x } , #{ text_size . y } , #{ text_size . w } , #{ text_size . h } \" ] end Sprites: args.outputs.sprites # args.outputs.sprites is used to render sprites. All primitives in GTK have the same considerations as detailed in the Labels section. - Minimum Code # # # X Y WIDTH HEIGHT PATH args . outputs . sprites << [ 100 , 100 , 32 , 64 , \"sprites/player.png\" ] - Extended Capabilities # # args . outputs . sprites << [ 100 , # X 100 , # Y 32 , # W 64 , # H \"player.png\" , # PATH 0 , # ANGLE 255 , # ALPHA 0 , # RED_SATURATION 255 , # GREEN_SATURATION 0 # BLUE_SATURATION ] - Named Parameters/Additional Metadata # # Here are all the properties for sprites : args . outputs . sprites << { x : 100 , y : 100 , w : 100 , h : 100 , path : \"sprites/player.png\" , angle : 0 , a , 255 r : 255 , g : 255 , b : 255 , source_x : 0 , source_y : 0 , source_w : - 1 , source_h : - 1 , flip_vertically : false , flip_horizontally : false , angle_anchor_x : 0 . 5 , angle_anchor_y : 1 . 0 } Sounds args.outputs.sounds # Sounds that end .wav will play once: args.outputs.sounds << 'something.wav' . Sounds that end .ogg is considered background music and will loop: args.outputs.sounds << 'background_music.ogg' . If you want to play a .ogg once as if it were a sound effect, you can do: args.gtk.queue_sound 'some-ogg.ogg' Args' State args.state # args.state is where you can put all of your game state. Tick Count args.state.tick_count GTK has a fixed time step of 60 frames per second. You can access the current tick_count using args.state.tick_count : def tick args # Render a label showing the current tick_count. args . outputs . labels << [ 360 , 640 , args . state . tick_count ] end - Working With \"Open\" Game State # # args.state is a \"open\" data structure that allows you to define properties of any structure. You don't need to define any kind of class . To initialize your game state, use the ||= operator. Any value on the right side of ||= will only be assigned once . To assign a value every frame, just use the = operator, but make sure you've initalized a default value. def tick args # initialize your game state ONCE args . player . x ||= 0 args . player . y ||= 0 args . player . hp ||= 100 # increment the x position of the character by one every frame args . player . x += 1 # Render a sprite with a label above the sprite # X Y W H PATH args . outputs . sprites << [ args . player . x , args . player . y , 32 , 32 \"player.png\" ] # X Y TEXT args . outputs . labels << [ args . player . x , args . player . y - 50 , args . player . hp ] end Args' Inputs: args.inputs # # Numeric # Numeric#elapsed? # Returns true if a numeric value plus an offset represents a point in time that has elapsed. This is related to args.state.tick_count. args.state.attacked_at ||= args.state.tick_count puts args.state.attacked_at.elapsed? 60 # will print false after one second. GTK # gtk.current_framerate - Returns current framerate gtk.pin_to_30fps? - Returns boolean determining if gtk is pinned to 30 FPS gtk.pause! - Pauses game gtk.paused - Returns boolean determining if game is paused gtk.paused= - Allows you to change value of pause gtk.unpause! - Unpauses game","title":"Cheatsheet"},{"location":"97-cheatsheet/#dragonruby-game-toolkit-cheatsheet","text":"A detailed documentation listing is located at mygame/documentation . For real world sample usages of GTK's APIs, take a look at the samples directory. The sample apps are ordered by beginner to advanced. So look at them in order to get the most out of them.","title":"DragonRuby Game Toolkit Cheatsheet"},{"location":"97-cheatsheet/#minimum-code-for-game","text":"The minimum amount of code required for a game is a file named mygame/main.rb with the following: def tick args args . outputs . labels << [ 640 , 360 , \"Hello World\" ] end","title":"Minimum Code for Game"},{"location":"97-cheatsheet/#args-args","text":"All of GTK's functionality hangs off of args .","title":"Args: args"},{"location":"97-cheatsheet/#args-outputs-argsoutputs","text":"All render primitive s are accessible under args.outputs .","title":"Args' Outputs: args.outputs"},{"location":"97-cheatsheet/#labels-argsoutputslabels","text":"args.outputs.labels is used to render labels. Labels are how you display text. This code will go directly inside of the def tick args method.","title":"Labels: args.outputs.labels"},{"location":"97-cheatsheet/#-minimum-code","text":"# X Y TEXT args . outputs . labels << [ 640 , 360 , \"I am a black label.\" ]","title":"- Minimum Code#"},{"location":"97-cheatsheet/#-a-colored-label","text":"# A colored label # X Y TEXT, RED GREEN BLUE ALPHA args . outputs . labels << [ 640 , 360 , \"I am a redish label.\" , 255 , 128 , 128 , 255 ]","title":"- A Colored Label#"},{"location":"97-cheatsheet/#-extended-capabilities","text":"# A colored label # X Y TEXT SIZE ALIGNMENT RED GREEN BLUE ALPHA FONT FILE args . outputs . labels << [ 640 , 360 , \"Hello world\" , 0 , 1 , 0 , 0 , 0 , 255 , \"fonts/coolfont.ttf\" ] A SIZE of 0 represents \"default size\". A negative value will decrease the label size. A positive value will increase the label's size. An ALIGNMENT of 0 represents \"left aligned\". 1 represents \"center aligned\". 2 represents \"right aligned\".","title":"- Extended Capabilities#"},{"location":"97-cheatsheet/#-named-parametersadditional-metadata","text":"You can add additional metadata about your game within a label, which requires you to use a Hash instead. args . outputs . labels << { x : 200 , y : 550 , text : \"dragonruby\" , size_enum : 2 , alignment_enum : 1 , r : 155 , g : 50 , b : 50 , a : 255 , font : \"fonts/manaspc.ttf\" , # You can add any properties you like (this will be ignored/won't cause errors) game_data_one : \"Something\" , game_data_two : { value_1 : \"value\" , value_2 : \"value two\" , a_number : 15 } } Getting The Size of a Piece of Text:# --- args.gtk.calcstringbox def tick args # local variable # TEXT SIZE_ENUM FONT text_size = args . gtk . args . calcstringbox ( \"some string\" , 0 , \"font.ttf\" ) # print size of a label to screen using Ruby's string formatting capabilities: #{} args . outputs . labels << [ 640 , 360 , \"the label's size is: #{ text_size . x } , #{ text_size . y } , #{ text_size . w } , #{ text_size . h } \" ] end","title":"- Named Parameters/Additional Metadata#"},{"location":"97-cheatsheet/#sprites-argsoutputssprites","text":"args.outputs.sprites is used to render sprites. All primitives in GTK have the same considerations as detailed in the Labels section.","title":"Sprites: args.outputs.sprites"},{"location":"97-cheatsheet/#-minimum-code_1","text":"# X Y WIDTH HEIGHT PATH args . outputs . sprites << [ 100 , 100 , 32 , 64 , \"sprites/player.png\" ]","title":"- Minimum Code#"},{"location":"97-cheatsheet/#-extended-capabilities_1","text":"args . outputs . sprites << [ 100 , # X 100 , # Y 32 , # W 64 , # H \"player.png\" , # PATH 0 , # ANGLE 255 , # ALPHA 0 , # RED_SATURATION 255 , # GREEN_SATURATION 0 # BLUE_SATURATION ]","title":"- Extended Capabilities#"},{"location":"97-cheatsheet/#-named-parametersadditional-metadata_1","text":"Here are all the properties for sprites : args . outputs . sprites << { x : 100 , y : 100 , w : 100 , h : 100 , path : \"sprites/player.png\" , angle : 0 , a , 255 r : 255 , g : 255 , b : 255 , source_x : 0 , source_y : 0 , source_w : - 1 , source_h : - 1 , flip_vertically : false , flip_horizontally : false , angle_anchor_x : 0 . 5 , angle_anchor_y : 1 . 0 }","title":"- Named Parameters/Additional Metadata#"},{"location":"97-cheatsheet/#sounds-argsoutputssounds","text":"Sounds that end .wav will play once: args.outputs.sounds << 'something.wav' . Sounds that end .ogg is considered background music and will loop: args.outputs.sounds << 'background_music.ogg' . If you want to play a .ogg once as if it were a sound effect, you can do: args.gtk.queue_sound 'some-ogg.ogg'","title":"Sounds args.outputs.sounds"},{"location":"97-cheatsheet/#args-state-argsstate","text":"args.state is where you can put all of your game state. Tick Count args.state.tick_count GTK has a fixed time step of 60 frames per second. You can access the current tick_count using args.state.tick_count : def tick args # Render a label showing the current tick_count. args . outputs . labels << [ 360 , 640 , args . state . tick_count ] end","title":"Args' State args.state"},{"location":"97-cheatsheet/#-working-with-open-game-state","text":"args.state is a \"open\" data structure that allows you to define properties of any structure. You don't need to define any kind of class . To initialize your game state, use the ||= operator. Any value on the right side of ||= will only be assigned once . To assign a value every frame, just use the = operator, but make sure you've initalized a default value. def tick args # initialize your game state ONCE args . player . x ||= 0 args . player . y ||= 0 args . player . hp ||= 100 # increment the x position of the character by one every frame args . player . x += 1 # Render a sprite with a label above the sprite # X Y W H PATH args . outputs . sprites << [ args . player . x , args . player . y , 32 , 32 \"player.png\" ] # X Y TEXT args . outputs . labels << [ args . player . x , args . player . y - 50 , args . player . hp ] end","title":"- Working With \"Open\" Game State#"},{"location":"97-cheatsheet/#args-inputs-argsinputs","text":"","title":"Args' Inputs: args.inputs"},{"location":"97-cheatsheet/#_1","text":"","title":""},{"location":"97-cheatsheet/#numeric","text":"","title":"Numeric"},{"location":"97-cheatsheet/#numericelapsed","text":"Returns true if a numeric value plus an offset represents a point in time that has elapsed. This is related to args.state.tick_count. args.state.attacked_at ||= args.state.tick_count puts args.state.attacked_at.elapsed? 60 # will print false after one second.","title":"Numeric#elapsed?"},{"location":"97-cheatsheet/#gtk","text":"gtk.current_framerate - Returns current framerate gtk.pin_to_30fps? - Returns boolean determining if gtk is pinned to 30 FPS gtk.pause! - Pauses game gtk.paused - Returns boolean determining if game is paused gtk.paused= - Allows you to change value of pause gtk.unpause! - Unpauses game","title":"GTK"},{"location":"98-faq/","text":"This documentation is still under development. Click here to contribute Where do I start? Start with the readme.txt file and follow the instructions in there based on your experience level. The next thing you want to look at is the CheatSheet and skim it. Go to mygame/documentation for a collection of markdown files that expand on what's in cheetsheet.txt. Go through the samples under the samples directory in order. They increase in difficulty. Within each sample is an api listing of what was used. There is a file called ctags-emacs that contains all internal functions in DragonRuby. If you can't find what you need in the locations above, go there for a hint about something that might help you and ask @amirrajan to elaborate. You'll also what to check out the Github . There are documentation contributions by the community here . Is DragonRuby-GTK OpenSource? Parts of the engine are open source (MIT) and can be found on Github . We cannot legally open source all of DragonRuby because of NDA agreements with game console manufacturers. If there is something you'd like to see the source for, just ask @amirrajan and he'll see if he can accommodate it. Does DragonRuby support Gems? What version of Ruby is DragonRuby? Definition of Terms # A bit of context/clarification is needed before answering this question. The general definition of Ruby (or any language for that matter) isn't sufficient when answering this question in detail. We have to split Ruby into three separate things. The Language Specification , the Runtime , and the Core Libraries . Language Specification # This represents the language's semantics and syntax (how the language is parsed). For example, Ruby 1.9 does not support keyword arguments, Ruby 2.0 does. Ruby 3.0 deprecates the \"last argument as a Hash\" parsing and forces you to use the double splat operator. Runtime # This represents the unique implementation/execution. Examples of Runtimes that implement Ruby's Language Specification are: MRI, mRuby, JRuby, Truffle, Artichoke, Opal. Core Libraries # This represents the libraries/classes that are supported for a specific runtime. For example: MRI Ruby's core libs are different that JRuby's core libs, which are both different from mRuby's corelibs, etc. Applying These Terms to DragonRuby # With the clarification of terms above. DragonRuby is compatible with Ruby 2.0's Language Specification. DragonRuby's Runtime is inspired by what's been learned over the past 25 years of MRI. It's inspired by mRuby, Objective C, C++, LLVM, NodeJS, Erlang, and Clojure. The specific inspirations are varied, nuanced, and evolving (feel free to asking questions in #general if you want specific). DragonRuby's Core Libraries are constrained by what can be implemented in a portable fashion and takes a strong dependency on libSDL2 and other portable C libraries. Now to Answer the Question About Gems DragonRuby's Ruby will eventually have gem capabilities, but it's unlikely that you'll be able to use MRI based gems, JRuby gems, et al. So when DragonRuby has a gem cli app, the only gems that will work will be those that were explicitly designed for DragonRuby. We also cannot use MRI's gem binary because it isn't portable (MRI assumes a conventional file system which is not the case for the platforms we target. What will DragonRuby's Gems Look Like DragonRuby's gem architecture will mostly likely depend on things like CocoaPods for iOS/Mac, Gradle for Android, mRuby's gem architecture, and CLibs. This is a lot of work... Stopgap Until we Have Gems If there's an MRI gem that you'd like to leverage. Let @amirrajan know and he'll add it to #feature-requests. Does DragonRuby have a REPL/IRB? You can use DragonRuby's Console within the game to inspect object and execute small pieces of code. For more complex pieces of code create a file called repl.rb and put it in mygame/app/repl.rb: 1. Any code you write in there will be executed when you change the file. You can organize different pieces of code using the repl method: repl do puts \"hello world\" ` puts 1 + 1 end If you use the repl method, the code will be executed and the DragonRuby Console will automatically open so you can see the results (on Mac and Linux, the results will also be printed to the terminal). All puts statements will also be saved to logs/log.txt. So if you want to stay in your editor and not look at the terminal, or the DragonRuby Console, you can tail this file. To ignore code in repl.rb, instead of commenting it out, prefix repl with the letter x and it'll be ignored. # This code will be executed when you save the file.# --- repl do puts \"Hello\" end repl do puts \"This code will also be executed.\" end # use xrepl to \"comment out\" code# --- xrepl do puts \"This code will not be executed because of the x infront of repl\" . end Does DragonRuby support C Extensions? Eventually yes. But it will be a \"Pro\" feature and require some form of subscription. Maintaining the compilation toolchain has an ongoing upkeep and a recurring subscription is the only way this work can be sustainably done. The pricing model will be fair I promise. If you're interested in creating C Extensions, DM @amirrajan and we'll figure out something that works for both of us (especially if you can't afford to pay the subscription if/when this happens). Does DragonRuby support Pry? IMPORTANT You must first read the \"Does Dragonruby support Gems\" section to get a bit of context. The following answer assumes you've read this. Pry is a gem that assumes you are using the MRI Runtime (which is incompatible with DragonRuby). Eventually DragonRuby will have a pry based experience that is compatible with a debugging infrastructure called LLDB. Take the time to read about LLDB as it shows the challenges in creating something that is compatible. Stopgap 1. DragonRuby is hot loaded which gives you a very fast feedback loop (if the game throws an exception, it's because of the code you just added). Use ./dragonruby mygame --record to create a game play recording that you can use to find the exception (you can replay a recoding by executing ./dragonruby mygame --replay last_replay.txt or through the DragonRuby Console using $gtk.recording.start_replay \"last_replay.txt\". DragonRuby also ships with a unit testing facility. Take a look at samples/99_zz_gtk_unit_tests to see how you can create your own unit tests. Get into the habit of adding debugging facilities within the game itself. You can add drawing primitives to args.outputs.debug that will render on top of your game but will be ignored in a production release. Debugging something that runs at 60fps is (imo) not that helpful. The exception you are seeing could have been because of a change that occurred many frames ago. What is args.state.new_entity (OpenEntity) or args.state.new_entity_strict (StrictEntity) ? When should I use it over Arrays, Hashes, and Classes? The Entity type's underlying interface is a Hash. Using entity.hash gives you by reference access to the Entity. This is why the method isn't called to_h which communicates that a new object would be created. TODO : Write more stuff about entities What are the Kernel.caller_locations ? We are dealing with a hot loaded environment where the code could be written in a file, saved, then removed. We are also dealing with OS'es that don't even have a concept of a conventional file system. This is further \"complected\" because of native interop, AOT compilation, and bytecode compilation. Don't expect this to happen. Performance Issues If you're using Arrays for your primitives ( args.outputs.sprites << [] ), use Hash instead ( args.outputs.sprites << { x: ... } ). If you're using Entity for your primitives ( args.outputs.sprites << args.state.new_entity ), use StrictEntity instead ( args.outputs.sprites << args.state.new_entity_strict ). Use .each instead of .map if you don't care about the return value. When concatenating primitives to outputs, do them in bulk. Instead of: args . state . bullets . each do | bullet | args . outputs . sprites << bullet . sprite end do args . outputs . sprites << args . state . bullets . map do | b | b . sprite end Use args.outputs.static_ variant for things that don't change often (take a look at the Basic Gorillas sample app and Dueling Starships sample app to see how static_ is leveraged. Consider using a render_target if you're doing some form of a camera that moves a lot of primitives (take a look at the Render Target sample apps for more info).","title":"FAQ"},{"location":"98-faq/#definition-of-terms","text":"A bit of context/clarification is needed before answering this question. The general definition of Ruby (or any language for that matter) isn't sufficient when answering this question in detail. We have to split Ruby into three separate things. The Language Specification , the Runtime , and the Core Libraries .","title":"Definition of Terms"},{"location":"98-faq/#language-specification","text":"This represents the language's semantics and syntax (how the language is parsed). For example, Ruby 1.9 does not support keyword arguments, Ruby 2.0 does. Ruby 3.0 deprecates the \"last argument as a Hash\" parsing and forces you to use the double splat operator.","title":"Language Specification"},{"location":"98-faq/#runtime","text":"This represents the unique implementation/execution. Examples of Runtimes that implement Ruby's Language Specification are: MRI, mRuby, JRuby, Truffle, Artichoke, Opal.","title":"Runtime"},{"location":"98-faq/#core-libraries","text":"This represents the libraries/classes that are supported for a specific runtime. For example: MRI Ruby's core libs are different that JRuby's core libs, which are both different from mRuby's corelibs, etc.","title":"Core Libraries"},{"location":"98-faq/#applying-these-terms-to-dragonruby","text":"With the clarification of terms above. DragonRuby is compatible with Ruby 2.0's Language Specification. DragonRuby's Runtime is inspired by what's been learned over the past 25 years of MRI. It's inspired by mRuby, Objective C, C++, LLVM, NodeJS, Erlang, and Clojure. The specific inspirations are varied, nuanced, and evolving (feel free to asking questions in #general if you want specific). DragonRuby's Core Libraries are constrained by what can be implemented in a portable fashion and takes a strong dependency on libSDL2 and other portable C libraries. Now to Answer the Question About Gems DragonRuby's Ruby will eventually have gem capabilities, but it's unlikely that you'll be able to use MRI based gems, JRuby gems, et al. So when DragonRuby has a gem cli app, the only gems that will work will be those that were explicitly designed for DragonRuby. We also cannot use MRI's gem binary because it isn't portable (MRI assumes a conventional file system which is not the case for the platforms we target. What will DragonRuby's Gems Look Like DragonRuby's gem architecture will mostly likely depend on things like CocoaPods for iOS/Mac, Gradle for Android, mRuby's gem architecture, and CLibs. This is a lot of work... Stopgap Until we Have Gems If there's an MRI gem that you'd like to leverage. Let @amirrajan know and he'll add it to #feature-requests. Does DragonRuby have a REPL/IRB? You can use DragonRuby's Console within the game to inspect object and execute small pieces of code. For more complex pieces of code create a file called repl.rb and put it in mygame/app/repl.rb: 1. Any code you write in there will be executed when you change the file. You can organize different pieces of code using the repl method: repl do puts \"hello world\" ` puts 1 + 1 end If you use the repl method, the code will be executed and the DragonRuby Console will automatically open so you can see the results (on Mac and Linux, the results will also be printed to the terminal). All puts statements will also be saved to logs/log.txt. So if you want to stay in your editor and not look at the terminal, or the DragonRuby Console, you can tail this file. To ignore code in repl.rb, instead of commenting it out, prefix repl with the letter x and it'll be ignored. # This code will be executed when you save the file.# --- repl do puts \"Hello\" end repl do puts \"This code will also be executed.\" end # use xrepl to \"comment out\" code# --- xrepl do puts \"This code will not be executed because of the x infront of repl\" . end Does DragonRuby support C Extensions? Eventually yes. But it will be a \"Pro\" feature and require some form of subscription. Maintaining the compilation toolchain has an ongoing upkeep and a recurring subscription is the only way this work can be sustainably done. The pricing model will be fair I promise. If you're interested in creating C Extensions, DM @amirrajan and we'll figure out something that works for both of us (especially if you can't afford to pay the subscription if/when this happens). Does DragonRuby support Pry? IMPORTANT You must first read the \"Does Dragonruby support Gems\" section to get a bit of context. The following answer assumes you've read this. Pry is a gem that assumes you are using the MRI Runtime (which is incompatible with DragonRuby). Eventually DragonRuby will have a pry based experience that is compatible with a debugging infrastructure called LLDB. Take the time to read about LLDB as it shows the challenges in creating something that is compatible. Stopgap 1. DragonRuby is hot loaded which gives you a very fast feedback loop (if the game throws an exception, it's because of the code you just added). Use ./dragonruby mygame --record to create a game play recording that you can use to find the exception (you can replay a recoding by executing ./dragonruby mygame --replay last_replay.txt or through the DragonRuby Console using $gtk.recording.start_replay \"last_replay.txt\". DragonRuby also ships with a unit testing facility. Take a look at samples/99_zz_gtk_unit_tests to see how you can create your own unit tests. Get into the habit of adding debugging facilities within the game itself. You can add drawing primitives to args.outputs.debug that will render on top of your game but will be ignored in a production release. Debugging something that runs at 60fps is (imo) not that helpful. The exception you are seeing could have been because of a change that occurred many frames ago. What is args.state.new_entity (OpenEntity) or args.state.new_entity_strict (StrictEntity) ? When should I use it over Arrays, Hashes, and Classes? The Entity type's underlying interface is a Hash. Using entity.hash gives you by reference access to the Entity. This is why the method isn't called to_h which communicates that a new object would be created. TODO : Write more stuff about entities What are the Kernel.caller_locations ? We are dealing with a hot loaded environment where the code could be written in a file, saved, then removed. We are also dealing with OS'es that don't even have a concept of a conventional file system. This is further \"complected\" because of native interop, AOT compilation, and bytecode compilation. Don't expect this to happen. Performance Issues If you're using Arrays for your primitives ( args.outputs.sprites << [] ), use Hash instead ( args.outputs.sprites << { x: ... } ). If you're using Entity for your primitives ( args.outputs.sprites << args.state.new_entity ), use StrictEntity instead ( args.outputs.sprites << args.state.new_entity_strict ). Use .each instead of .map if you don't care about the return value. When concatenating primitives to outputs, do them in bulk. Instead of: args . state . bullets . each do | bullet | args . outputs . sprites << bullet . sprite end do args . outputs . sprites << args . state . bullets . map do | b | b . sprite end Use args.outputs.static_ variant for things that don't change often (take a look at the Basic Gorillas sample app and Dueling Starships sample app to see how static_ is leveraged. Consider using a render_target if you're doing some form of a camera that moves a lot of primitives (take a look at the Render Target sample apps for more info).","title":"Applying These Terms to DragonRuby"},{"location":"99-todo/","text":"This documentation is still under development. Click here to contribute Documentation That Needs to be Organized # Class macro gtk_args # Here's how you can use the gtk_args class method: class Game gtk_args attr_accessor :current_scene , :other_custom_attrs def tick end end $game = Game . new def tick args $game . args = args $game . tick end The code above is the similar to: class Game attr_accessor :args , :grid , :state , :inputs , :outputs , :gtk , :passes , :current_scene , :other_custom_attrs def tick end end $game = Game . new def tick args $game . args = args $game . grid = args . grid $game . state = args . state $game . outputs = args . outputs $game . gtk = args . gtk $game . passes = args . passes $game . tick end Monkey patching the runtime # You're on your own if you do this module GTK class Runtime alias_method :__original_tick_core__ , :tick_core unless Runtime . instance_methods . include? ( :__original_tick_core__ ) def tick_core __original_tick_core__ $top_level . oh @args $top_level . god @args $top_level . why @args end end end def tick args end def oh args end def god args end def why args end","title":"To Do"},{"location":"99-todo/#documentation-that-needs-to-be-organized","text":"","title":"Documentation That Needs to be Organized"},{"location":"99-todo/#class-macro-gtk_args","text":"Here's how you can use the gtk_args class method: class Game gtk_args attr_accessor :current_scene , :other_custom_attrs def tick end end $game = Game . new def tick args $game . args = args $game . tick end The code above is the similar to: class Game attr_accessor :args , :grid , :state , :inputs , :outputs , :gtk , :passes , :current_scene , :other_custom_attrs def tick end end $game = Game . new def tick args $game . args = args $game . grid = args . grid $game . state = args . state $game . outputs = args . outputs $game . gtk = args . gtk $game . passes = args . passes $game . tick end","title":"Class macro gtk_args"},{"location":"99-todo/#monkey-patching-the-runtime","text":"You're on your own if you do this module GTK class Runtime alias_method :__original_tick_core__ , :tick_core unless Runtime . instance_methods . include? ( :__original_tick_core__ ) def tick_core __original_tick_core__ $top_level . oh @args $top_level . god @args $top_level . why @args end end end def tick args end def oh args end def god args end def why args end","title":"Monkey patching the runtime"},{"location":"about/","text":"This documentation is still under development. Click here to contribute About DragonRuby-GTK # Ryan # This is Ryan C. Gordon , he is one of the juggernauts behind Simple DirectMedia Layer . Ya know... SDL. That low level library that powers literally every commercial game engine out there? He's also worked on porting a number of games to Linux and Mac OS: such as Braid, Super Meat Boy, Dear Esther, and LIMBO. Amir # And this is Amir Rajan , he is an indie game dev with titles on iOS, Android, desktop, and Nintendo Switch... amassing 4 million downloads and counting ( Nintendo , Kill Screen , The New Yorker ). And yes, all these games are built with the DragonRuby Runtime. Both of these guys hate the complexity of today's engines. And as luck would have it, their paths ended up crossing. After six months and 50,000 lines of DragonRuby Runtime enhancements, Ryan and Amir now have a live/hot loadable, cruft-free, productive game engine that can target... well... any gaming device you can think of.","title":"About"},{"location":"about/#about-dragonruby-gtk","text":"","title":"About DragonRuby-GTK"},{"location":"about/#ryan","text":"This is Ryan C. Gordon , he is one of the juggernauts behind Simple DirectMedia Layer . Ya know... SDL. That low level library that powers literally every commercial game engine out there? He's also worked on porting a number of games to Linux and Mac OS: such as Braid, Super Meat Boy, Dear Esther, and LIMBO.","title":"Ryan"},{"location":"about/#amir","text":"And this is Amir Rajan , he is an indie game dev with titles on iOS, Android, desktop, and Nintendo Switch... amassing 4 million downloads and counting ( Nintendo , Kill Screen , The New Yorker ). And yes, all these games are built with the DragonRuby Runtime. Both of these guys hate the complexity of today's engines. And as luck would have it, their paths ended up crossing. After six months and 50,000 lines of DragonRuby Runtime enhancements, Ryan and Amir now have a live/hot loadable, cruft-free, productive game engine that can target... well... any gaming device you can think of.","title":"Amir"},{"location":"license/","text":"This documentation is still under development. Click here to contribute Licensing # Free Unrestricted License # You are eligible for a free license if any of the following items pertain to you: Your income is below $2000 (USD) per month. You are under 18 years of age. You are a student of any type: traditional public school, home schooling, college, bootcamp, or online. You are a teacher, mentor, or parent who wants to teach a kid how to code. You are a Raspberry PI enthusiast who wants to build games for it. You work/worked in public service or at a charitable organization: for example public office, army, or any 501\u00a9(3) organization. Just contact Amir at ar@amirrajan.net with a short explanation of your current situation and he'll set you up. No questions asked.","title":"Licensing"},{"location":"license/#licensing","text":"","title":"Licensing"},{"location":"license/#free-unrestricted-license","text":"You are eligible for a free license if any of the following items pertain to you: Your income is below $2000 (USD) per month. You are under 18 years of age. You are a student of any type: traditional public school, home schooling, college, bootcamp, or online. You are a teacher, mentor, or parent who wants to teach a kid how to code. You are a Raspberry PI enthusiast who wants to build games for it. You work/worked in public service or at a charitable organization: for example public office, army, or any 501\u00a9(3) organization. Just contact Amir at ar@amirrajan.net with a short explanation of your current situation and he'll set you up. No questions asked.","title":"Free Unrestricted License"},{"location":"tutorials/advanced/","text":"This documentation is still under development. Click here to contribute Advanced # Recommended for individuals familia with Dynamically Typed Languages (Ruby, Lua, Python, or JavaScript) Work through this Hello World Tutorial Skim through the CheatSheet to get a feel for some of the other API's you have access to. If you never even more detail, you'll find them on the left hand side of these pages. Run each sample app in order and read the code. * The sample apps are located in the sample directory and are ordered by increasing complexity. Run each one of them and read through the code. Play around by changing values and see how they change the game. * Integrate your editor. There is a file called vim-ctags and emacs-ctags . The data in these files are standard output provided by Exuberent CTAGS. Most editors have a \"ctags plugin\" so just search for that plugin for your editor and point it to these files. Get in the habit of reading the CHANGELOG. We are constantly adding new features to the engine. Be sure to read the changelog with every release.","title":"Advanced"},{"location":"tutorials/advanced/#advanced","text":"Recommended for individuals familia with Dynamically Typed Languages (Ruby, Lua, Python, or JavaScript) Work through this Hello World Tutorial Skim through the CheatSheet to get a feel for some of the other API's you have access to. If you never even more detail, you'll find them on the left hand side of these pages. Run each sample app in order and read the code. * The sample apps are located in the sample directory and are ordered by increasing complexity. Run each one of them and read through the code. Play around by changing values and see how they change the game. * Integrate your editor. There is a file called vim-ctags and emacs-ctags . The data in these files are standard output provided by Exuberent CTAGS. Most editors have a \"ctags plugin\" so just search for that plugin for your editor and point it to these files. Get in the habit of reading the CHANGELOG. We are constantly adding new features to the engine. Be sure to read the changelog with every release.","title":"Advanced"},{"location":"tutorials/beginner/","text":"This documentation is still under development. Click here to contribute Beginner # Recommended for individuals with no programming experience If you have no programing experience at all. You'll want to take the time to see what DragonRuby is like before jumping in to code. Watch the following videos in order (each one is only ~20 minutes long). ** Don't attempt to code anything shown in the video yet, just watch them to get familiar with the language and how games are built. ** Beginner Introduction to Ruby Intermediate Introduction to Ruby Syntax Intermediate Introduction to Arrays in Ruby Once you have watched all the videos. Then (and only then) go back through the videos and follow along. Sample Location Beginner Introducation to Ruby samples/00_beginner_ruby_primer Intermediate Introduction to Ruby Syntax samples/00_intermediate_ruby_primer Intermediate Introduction to Arrays in Ruby samples/00_intermediate_ruby_primer","title":"Beginner"},{"location":"tutorials/beginner/#beginner","text":"Recommended for individuals with no programming experience If you have no programing experience at all. You'll want to take the time to see what DragonRuby is like before jumping in to code. Watch the following videos in order (each one is only ~20 minutes long). ** Don't attempt to code anything shown in the video yet, just watch them to get familiar with the language and how games are built. ** Beginner Introduction to Ruby Intermediate Introduction to Ruby Syntax Intermediate Introduction to Arrays in Ruby Once you have watched all the videos. Then (and only then) go back through the videos and follow along. Sample Location Beginner Introducation to Ruby samples/00_beginner_ruby_primer Intermediate Introduction to Ruby Syntax samples/00_intermediate_ruby_primer Intermediate Introduction to Arrays in Ruby samples/00_intermediate_ruby_primer","title":"Beginner"},{"location":"tutorials/hello-world/","text":"This documentation is still under development. Click here to contribute Hello World Tutorial # Part 1 # By Ryan 'The Juggernaut' Gordon Welcome! Here's just a little push to get you started if you're new to programming or game development. If you want to write a game, it's no different than writing any other program for any other framework: there are a few simple rules that might be new to you, but more or less programming is programming no matter what you are building. Did you not know that? Did you think you couldn't write a game because you're a \"web guy\" or you're writing Java at a desk job? Stop letting people tell you that you can't, because you already have everything you need. Here, we're going to be programming in a language called \"Ruby.\" In the interest of full disclosure, I (Ryan \"The Juggernaut\" Gordon) wrote the C parts of this toolkit and Ruby looks a little strange to me (Amir Rajan wrote the Ruby parts), but I'm going to walk you through the basics because we're all learning together, and if you mostly think of yourself as someone that writes C (or C++, C#, Objective-C), PHP, or Java, then you're only a step behind me right now. Here's the most important thing you should know: **Ruby lets you do some complicated things really easily, and you can learn that stuff later. ** I'm going to show you one or two cool tricks, but that's all. Part 2 # Do you know what an if statement is? A for-loop? An array? That's all you'll need to start. Ok, here are few rules with regards to game development with GTK: Your game is all going to happen under one function... ...that runs 60 times a second... ...and has to tell the computer what to draw each time. That's an entire video game in one run-on sentence. Here's that function. You're going to want to put this in mygame/app/main.rb, because that's where we'll look for it by default. Load it up in your favorite text editor. def tick args args . outputs . labels << [ 580 , 400 , 'Hello World!' ] end Now run dragonruby ...did you get a window with \"Hello World!\" written in it? Good, you're officially a game developer! mygame/app/main.rb , is where the Ruby source code is located. This looks a little strange, so I'll break it down line by line. In Ruby, a '#' character starts a single-line comment, so I'll talk about this inline. # This \"def\"ines a function, named \"tick,\" which takes a single argument # named \"args\". DragonRuby looks for this function and calls it every # frame, 60 times a second. \"args\" is a magic structure with lots of # information in it. You can set variables in there for your own game state, # and every frame it will updated if keys are pressed, joysticks moved, # mice clicked, etc. def tick args # One of the things in \"args\" is the \"outputs\" object that your game uses # to draw things. Afraid of rendering APIs? No problem. In DragonRuby, # you use arrays to draw things and we figure out the details. # If you want to draw text on the screen, you give it an array (the thing # in the [ brackets ]), with an X and Y coordinate and the text to draw. # The \"<<\" thing says \"append this array onto the list of them at # args.outputs.labels) args . outputs . labels << [ 580 , 400 , 'Hello World!' ] end Once your tick function finishes, we look at all the arrays you made and figure out how to draw it. You don't need to know about graphics APIs. You're just setting up some arrays! DragonRuby clears out these arrays every frame, so you just need to add what you need right now each time. Part 3 # Now let's spice this up a little. We're going to add some graphics. Each 2D image in DragonRuby is called a \"sprite,\" and to use them, you just make sure they exist in a reasonable file format (png, jpg, gif, bmp, etc) and specify them by filename. The first time you use one, DragonRuby will load it and keep it in video memory for fast access in the future. If you use a filename that doesn't exist, you get a fun checkerboard pattern! There's a \"dragonruby.png\" file included, just to get you started. Let's have it draw every frame with our text: def tick args args . outputs . labels << [ 580 , 400 , 'Hello World!' ] args . outputs . sprites << [ 576 , 100 , 128 , 101 , 'dragonruby.png' ] end (ProTip: you don't have to restart DragonRuby to test your changes; when you save main.rb, DragonRuby will notice and reload your program.) That .sprites line says \"add a sprite to the list of sprites we're drawing, and draw it at position (576, 100) at a size of 128x101 pixels\". You can find the image to draw at dragonruby.png. Quick note about coordinates: (0, 0) is the bottom left corner of the screen, and positive numbers go up and to the right. This is more \"geometrically correct,\" even if it's not how you remember doing 2D graphics, but we chose this for a simpler reason: when you're making Super Mario Brothers and you want Mario to jump, you should be able to add to Mario's y position as he goes up and subtract as he falls. It makes things easier to understand. Also: your game screen is always 1280x720 pixels. If you resize the window, we will scale and letterbox everything appropriately, so you never have to worry about different resolutions. Ok, now we have an image on the screen, let's animate it: def tick args args . state . rotation ||= 0 args . outputs . labels << [ 580 , 400 , 'Hello World!' ] args . outputs . sprites << [ 576 , 100 , 128 , 101 , 'dragonruby.png' , args . state . rotation ] args . state . rotation -= 1 end Now you can see that this function is getting called a lot! Here's a fun Ruby thing: args.state.rotation ||= 0 is shorthand for \"if args.state.rotation isn't initialized, set it to zero.\" It's a nice way to embed your initialization code right next to where you need the variable. args.state is a place you can hang your own data and have it survive past the life of the function call. In this case, the current rotation of our sprite, which is happily spinning at 60 frames per second. If you don't specify rotation (or alpha, or color modulation, or a source rectangle, etc), DragonRuby picks a reasonable default, and the array is ordered by the most likely things you need to tell us: position, size, name. One thing we decided to do in DragonRuby is not make you worry about delta time: your function runs at 60 frames per second (about 16 milliseconds) and that's that. Having to worry about framerate is something massive triple-AAA games do, but for fun little 2D games? You'd have to work really hard to not hit 60fps. All your drawing is happening on a GPU designed to run Fortnite quickly; it can definitely handle this. Since we didn't make you worry about delta time, you can just move the rotation by 1 every time and it works without you having to keep track of time and math. Want it to move faster? Subtract 2. Now, let's move that image around. def tick args args . state . rotation ||= 0 args . state . x ||= 576 args . state . y ||= 100 if args . inputs . mouse . click args . state . x = args . inputs . mouse . click . point . x - 64 args . state . y = args . inputs . mouse . click . point . y - 50 end args . outputs . labels << [ 580 , 400 , 'Hello World!' ] args . outputs . sprites << [ args . state . x , args . state . y , 128 , 101 , 'dragonruby.png' , args . state . rotation ] args . state . rotation -= 1 end Everywhere you click your mouse, the image moves there. We set a default location for it with args.state.x ||= 576, and then we change those variables when we see the mouse button in action. You can get at the keyboard and game controllers in similar ways. There is a lot more you can do with DragonRuby, but now you've already got just about everything you need to make a simple game. After all, even the most fancy games are just creating objects and moving them around. Experiment a little. Add a few more things and have them interact in small ways. Want something to go away? Just don't add it to args.output anymore.","title":"Hello World"},{"location":"tutorials/hello-world/#hello-world-tutorial","text":"","title":"Hello World Tutorial"},{"location":"tutorials/hello-world/#part-1","text":"By Ryan 'The Juggernaut' Gordon Welcome! Here's just a little push to get you started if you're new to programming or game development. If you want to write a game, it's no different than writing any other program for any other framework: there are a few simple rules that might be new to you, but more or less programming is programming no matter what you are building. Did you not know that? Did you think you couldn't write a game because you're a \"web guy\" or you're writing Java at a desk job? Stop letting people tell you that you can't, because you already have everything you need. Here, we're going to be programming in a language called \"Ruby.\" In the interest of full disclosure, I (Ryan \"The Juggernaut\" Gordon) wrote the C parts of this toolkit and Ruby looks a little strange to me (Amir Rajan wrote the Ruby parts), but I'm going to walk you through the basics because we're all learning together, and if you mostly think of yourself as someone that writes C (or C++, C#, Objective-C), PHP, or Java, then you're only a step behind me right now. Here's the most important thing you should know: **Ruby lets you do some complicated things really easily, and you can learn that stuff later. ** I'm going to show you one or two cool tricks, but that's all.","title":"Part 1"},{"location":"tutorials/hello-world/#part-2","text":"Do you know what an if statement is? A for-loop? An array? That's all you'll need to start. Ok, here are few rules with regards to game development with GTK: Your game is all going to happen under one function... ...that runs 60 times a second... ...and has to tell the computer what to draw each time. That's an entire video game in one run-on sentence. Here's that function. You're going to want to put this in mygame/app/main.rb, because that's where we'll look for it by default. Load it up in your favorite text editor. def tick args args . outputs . labels << [ 580 , 400 , 'Hello World!' ] end Now run dragonruby ...did you get a window with \"Hello World!\" written in it? Good, you're officially a game developer! mygame/app/main.rb , is where the Ruby source code is located. This looks a little strange, so I'll break it down line by line. In Ruby, a '#' character starts a single-line comment, so I'll talk about this inline. # This \"def\"ines a function, named \"tick,\" which takes a single argument # named \"args\". DragonRuby looks for this function and calls it every # frame, 60 times a second. \"args\" is a magic structure with lots of # information in it. You can set variables in there for your own game state, # and every frame it will updated if keys are pressed, joysticks moved, # mice clicked, etc. def tick args # One of the things in \"args\" is the \"outputs\" object that your game uses # to draw things. Afraid of rendering APIs? No problem. In DragonRuby, # you use arrays to draw things and we figure out the details. # If you want to draw text on the screen, you give it an array (the thing # in the [ brackets ]), with an X and Y coordinate and the text to draw. # The \"<<\" thing says \"append this array onto the list of them at # args.outputs.labels) args . outputs . labels << [ 580 , 400 , 'Hello World!' ] end Once your tick function finishes, we look at all the arrays you made and figure out how to draw it. You don't need to know about graphics APIs. You're just setting up some arrays! DragonRuby clears out these arrays every frame, so you just need to add what you need right now each time.","title":"Part 2"},{"location":"tutorials/hello-world/#part-3","text":"Now let's spice this up a little. We're going to add some graphics. Each 2D image in DragonRuby is called a \"sprite,\" and to use them, you just make sure they exist in a reasonable file format (png, jpg, gif, bmp, etc) and specify them by filename. The first time you use one, DragonRuby will load it and keep it in video memory for fast access in the future. If you use a filename that doesn't exist, you get a fun checkerboard pattern! There's a \"dragonruby.png\" file included, just to get you started. Let's have it draw every frame with our text: def tick args args . outputs . labels << [ 580 , 400 , 'Hello World!' ] args . outputs . sprites << [ 576 , 100 , 128 , 101 , 'dragonruby.png' ] end (ProTip: you don't have to restart DragonRuby to test your changes; when you save main.rb, DragonRuby will notice and reload your program.) That .sprites line says \"add a sprite to the list of sprites we're drawing, and draw it at position (576, 100) at a size of 128x101 pixels\". You can find the image to draw at dragonruby.png. Quick note about coordinates: (0, 0) is the bottom left corner of the screen, and positive numbers go up and to the right. This is more \"geometrically correct,\" even if it's not how you remember doing 2D graphics, but we chose this for a simpler reason: when you're making Super Mario Brothers and you want Mario to jump, you should be able to add to Mario's y position as he goes up and subtract as he falls. It makes things easier to understand. Also: your game screen is always 1280x720 pixels. If you resize the window, we will scale and letterbox everything appropriately, so you never have to worry about different resolutions. Ok, now we have an image on the screen, let's animate it: def tick args args . state . rotation ||= 0 args . outputs . labels << [ 580 , 400 , 'Hello World!' ] args . outputs . sprites << [ 576 , 100 , 128 , 101 , 'dragonruby.png' , args . state . rotation ] args . state . rotation -= 1 end Now you can see that this function is getting called a lot! Here's a fun Ruby thing: args.state.rotation ||= 0 is shorthand for \"if args.state.rotation isn't initialized, set it to zero.\" It's a nice way to embed your initialization code right next to where you need the variable. args.state is a place you can hang your own data and have it survive past the life of the function call. In this case, the current rotation of our sprite, which is happily spinning at 60 frames per second. If you don't specify rotation (or alpha, or color modulation, or a source rectangle, etc), DragonRuby picks a reasonable default, and the array is ordered by the most likely things you need to tell us: position, size, name. One thing we decided to do in DragonRuby is not make you worry about delta time: your function runs at 60 frames per second (about 16 milliseconds) and that's that. Having to worry about framerate is something massive triple-AAA games do, but for fun little 2D games? You'd have to work really hard to not hit 60fps. All your drawing is happening on a GPU designed to run Fortnite quickly; it can definitely handle this. Since we didn't make you worry about delta time, you can just move the rotation by 1 every time and it works without you having to keep track of time and math. Want it to move faster? Subtract 2. Now, let's move that image around. def tick args args . state . rotation ||= 0 args . state . x ||= 576 args . state . y ||= 100 if args . inputs . mouse . click args . state . x = args . inputs . mouse . click . point . x - 64 args . state . y = args . inputs . mouse . click . point . y - 50 end args . outputs . labels << [ 580 , 400 , 'Hello World!' ] args . outputs . sprites << [ args . state . x , args . state . y , 128 , 101 , 'dragonruby.png' , args . state . rotation ] args . state . rotation -= 1 end Everywhere you click your mouse, the image moves there. We set a default location for it with args.state.x ||= 576, and then we change those variables when we see the mouse button in action. You can get at the keyboard and game controllers in similar ways. There is a lot more you can do with DragonRuby, but now you've already got just about everything you need to make a simple game. After all, even the most fancy games are just creating objects and moving them around. Experiment a little. Add a few more things and have them interact in small ways. Want something to go away? Just don't add it to args.output anymore.","title":"Part 3"},{"location":"tutorials/intermediate/","text":"This documentation is still under development. Click here to contribute Intermediate # Recommended for individuals familiar with C#(Unity) or GML(GameMaker) but new to Ruby Those engines rot your brain. Forget the concepts that the forced you to learn. Game development is so much simpler than what they make you do. Please, try your best to set aside the concepts those engines teach (we promise our approach to game development is much much easier). Watch these videos to get familiar with the Ruby language and programming environment (they are ~20 min each so it'll be quick): Beginner Introduction to Ruby Intermediate Introduction to Ruby Syntax Intermediate Introduction to Arrays in Ruby You may also want to try this free course provided at DragonRuby School After you've watch the videos, you'll be ready for the Advanced Tutorial","title":"Intermediate"},{"location":"tutorials/intermediate/#intermediate","text":"Recommended for individuals familiar with C#(Unity) or GML(GameMaker) but new to Ruby Those engines rot your brain. Forget the concepts that the forced you to learn. Game development is so much simpler than what they make you do. Please, try your best to set aside the concepts those engines teach (we promise our approach to game development is much much easier). Watch these videos to get familiar with the Ruby language and programming environment (they are ~20 min each so it'll be quick): Beginner Introduction to Ruby Intermediate Introduction to Ruby Syntax Intermediate Introduction to Arrays in Ruby You may also want to try this free course provided at DragonRuby School After you've watch the videos, you'll be ready for the Advanced Tutorial","title":"Intermediate"},{"location":"tutorials/publishing/","text":"This documentation is still under development. Click here to contribute Publishing Your Game # Once you've built your game, you're all set to deploy! Good luck in your game dev journey and if you get stuck, come to the Discord channel! 1. Create a new game in Itch.io # Log in and create a new game Here . Section Description Title This value represents your gametitle Project URL This value represents your gameid Classification Keep this as Game Kind of Project Select HTML from the drop down list. Dont worry about the HTML project type _aslo supports binary downloads_ Uploads Skip this section for now Embed Options Set the dropdown value to Click to launch in fullscreen . ** Do NOT use the ** Embed in page ** option. iFrames are not reliable with regards to capturing input ** You can fill out all the other options later. 2. Update your metadata # Point your text editor at mygame/metadata/game_metadata.txt and make it look like this: (Remove the # at the beginning of each line). devid=bob devtitle=Bob The Game Developer gameid=mygame gametitle=My Game version=0.1 |Item|Description| |--|--| | devid |The username you use to log into Itch.io| | devtitle |Your name or company name (it can contain spaces)| | gameid |The Project URL value (see details in STEP 1)| | gametitle |The name of your game (it can contain spaces)| | version |Can be any major.minor number format| 3. Build your game for distribution. # Open up the terminal and run this from the command line: ./dragonruby-publish --only-package mygame (if you're on Windows, don't put the ./ on the front) A directory called ./build will be created that contains your binaries. You can upload this to Itch.io manually. For the HTML version of your game after you upload it. Check the checkbox labeled This file will be played in the browser For subsequent updates you can use an automated deployment to Itch.io: ./dragonruby-publish mygame DragonRuby will package and publish your game to itch.io! Tell your friends to go to your game's very own webpage and buy it! If you make changes to your game, just re-run dragonruby-publish and it'll update the downloads for you.","title":"Publishing Your Game"},{"location":"tutorials/publishing/#publishing-your-game","text":"Once you've built your game, you're all set to deploy! Good luck in your game dev journey and if you get stuck, come to the Discord channel!","title":"Publishing Your Game"},{"location":"tutorials/publishing/#1-create-a-new-game-in-itchio","text":"Log in and create a new game Here . Section Description Title This value represents your gametitle Project URL This value represents your gameid Classification Keep this as Game Kind of Project Select HTML from the drop down list. Dont worry about the HTML project type _aslo supports binary downloads_ Uploads Skip this section for now Embed Options Set the dropdown value to Click to launch in fullscreen . ** Do NOT use the ** Embed in page ** option. iFrames are not reliable with regards to capturing input ** You can fill out all the other options later.","title":"1. Create a new game in Itch.io"},{"location":"tutorials/publishing/#2-update-your-metadata","text":"Point your text editor at mygame/metadata/game_metadata.txt and make it look like this: (Remove the # at the beginning of each line). devid=bob devtitle=Bob The Game Developer gameid=mygame gametitle=My Game version=0.1 |Item|Description| |--|--| | devid |The username you use to log into Itch.io| | devtitle |Your name or company name (it can contain spaces)| | gameid |The Project URL value (see details in STEP 1)| | gametitle |The name of your game (it can contain spaces)| | version |Can be any major.minor number format|","title":"2. Update your metadata"},{"location":"tutorials/publishing/#3-build-your-game-for-distribution","text":"Open up the terminal and run this from the command line: ./dragonruby-publish --only-package mygame (if you're on Windows, don't put the ./ on the front) A directory called ./build will be created that contains your binaries. You can upload this to Itch.io manually. For the HTML version of your game after you upload it. Check the checkbox labeled This file will be played in the browser For subsequent updates you can use an automated deployment to Itch.io: ./dragonruby-publish mygame DragonRuby will package and publish your game to itch.io! Tell your friends to go to your game's very own webpage and buy it! If you make changes to your game, just re-run dragonruby-publish and it'll update the downloads for you.","title":"3. Build your game for distribution."}]}